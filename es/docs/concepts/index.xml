<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jenkins X - Cloud Native CI/CD Built On Kubernetes – Conceptos</title>
    <link>https://jenkins-x.io/es/docs/concepts/</link>
    <description>Recent content in Conceptos on Jenkins X - Cloud Native CI/CD Built On Kubernetes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>es-ES</language>
    
	  <atom:link href="https://jenkins-x.io/es/docs/concepts/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: Componentes</title>
      <link>https://jenkins-x.io/es/docs/concepts/components/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jenkins-x.io/es/docs/concepts/components/</guid>
      <description>
        
        
        &lt;p&gt;Una instalación de Jenkins X consiste en:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;un Entorno de Desarrollo por equipo que corresponde con un &lt;a href=&#34;https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/&#34;&gt;namespace en Kubernetes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;de cero a muchos otros &lt;a href=&#34;https://jenkins-x.io/es/about/concepts/features/#entornos&#34;&gt;Entornos Permanentes&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;lo que está listo para se utilizado es que cada equipo tenga su propios entornos de &lt;code&gt;Staging&lt;/code&gt; y &lt;code&gt;Production&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;cada equipo puede tener tantos entornos como deseen y pueden nombrarlos de la manera que prefieran&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;opcional &lt;a href=&#34;https://jenkins-x.io/es/about/concepts/features/#entornos-de-vista-previa&#34;&gt;Vista Previa del Entorno&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Normalmente cada entorno es asociado con su propio &lt;a href=&#34;https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/&#34;&gt;namespace en Kubernetes&lt;/a&gt; para garantizar un correcto aislamiento entre entornos.&lt;/p&gt;
&lt;p&gt;Técnicamente 2 equipos podrían compartir el mismo espacio de nombres (mismo namespace en Kubernetes), pero esto podría traer problemas y por eso no lo recomendamos. Pensemos en el namespace &lt;code&gt;Staging&lt;/code&gt; y en 2 equipos donde cada uno tiene una aplicación en un repositorio Git, en total 2 repositorios. Al realizar cambios en uno de los repositorios Git se podrían generar conflictos con el otro en los nombres de los elementos o en los DNS. Para evitar estos problemas, es preferible mantener estructurar los equipos (las aplicaciones) en namespaces separados y realizar los enlaces entre servicios utilizando la estructura local DNS.&lt;/p&gt;
&lt;p&gt;Revise la lista completa de &lt;a href=&#34;https://jenkins-x.io/docs/reference/components/&#34;&gt;componentes de Jenkins X&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;entornos-de-desarrollo&#34;&gt;Entornos de Desarrollo&lt;/h2&gt;
&lt;p&gt;En el entorno de desarrollo, hemos instalado una serie de aplicaciones principales que creemos son necesarias como mínimo para comenzar con CI/CD en Kubernetes.&lt;/p&gt;
&lt;p&gt;También admitimos &lt;a href=&#34;https://jenkins-x.io/es/about/concepts/features/#aplicaciones&#34;&gt;complementos&lt;/a&gt; para ampliar este conjunto básico.&lt;/p&gt;
&lt;p&gt;Jenkins X viene con una configuración que conecta estos servicios entre sí, lo que significa que todo funciona de conjunto de inmediato. Esto reduce drásticamente el tiempo para comenzar con Kubernetes, ya que todas las contraseñas, las variables de entorno y los archivos de configuración están configurados para funcionar entre sí.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Jenkins&lt;/strong&gt; — proporciona la automatización de flujos CI/CD. Hay un esfuerzo para descomponer Jenkins con el tiempo para volverlo más nativo de la nube y hacer mayor uso de los conceptos de Kubernetes en torno a: CRD, almacenamiento, escalado, entre otros.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Nexus&lt;/strong&gt; — actúa como un caché de dependencia para aplicaciones NodeJS y Java para mejorar dramáticamente los tiempos de compilación. Después de una compilación inicial de una aplicación SpringBoot, el tiempo de compilación se reduce de 12 minutos a 4. Todavía no hemos intentado demostrar, pero lo haremos pronto, el intercambiarlo con Artifactory.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Docker registry&lt;/strong&gt;  — un registro de docker dentro del clúster donde nuestros pipelines envían imágenes de aplicaciones, pronto pasaremos a utilizar registros de proveedores nativos de la nube, como Google Container Registry, Azure Container Registry o Amazon Elastic Container Registry (ECR), por ejemplo.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ChartMuseum&lt;/strong&gt; — un Repositorio para publicar los charts de Helm&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Monocular&lt;/strong&gt;  — una interfaz de usuario utilizada para obtener y ejecutar charts de Helm&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;entornos-permanentes&#34;&gt;Entornos Permanentes&lt;/h2&gt;
&lt;p&gt;Estos &lt;a href=&#34;https://jenkins-x.io/es/about/concepts/features/#entornos&#34;&gt;entornos&lt;/a&gt;, como &lt;code&gt;Staging&lt;/code&gt; y &lt;code&gt;Production&lt;/code&gt; utilizan GitOps para auto-gestionarse, por lo que cada uno tiene asociado un repositorio Git con el código necesario para configurar todas las aplicaciones y servicios que son desplegados en el.&lt;/p&gt;
&lt;p&gt;Normalmente se utilizan charts de Helm dentro del repositorio para definir qué chart será instalado, que versión utilizar y cualquier otra configuración específica necesaria del entorno, así como recurso adicionales. p.ej. Información sensible (Secrets) o aplicaciones como Prometheus, etc.&lt;/p&gt;
&lt;h2 id=&#34;entornos-de-vista-previa&#34;&gt;Entornos de Vista Previa&lt;/h2&gt;
&lt;p&gt;Los &lt;a href=&#34;https://jenkins-x.io/es/about/concepts/features/#entornos-de-vista-previa&#34;&gt;Entornos de Vista Previa&lt;/a&gt; son similares a los &lt;a href=&#34;https://jenkins-x.io/es/about/concepts/features/#entornos&#34;&gt;Entornos Permanentes&lt;/a&gt; en el punto donde ambos están definidos en el código fuente utilizando los charts de Helm.&lt;/p&gt;
&lt;p&gt;La principal diferencia es que los entornos de vista previa están configurados dentro del código fuente de la aplicación, en la carpeta &lt;code&gt;./chart/preview&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Además, estos entornos no son permanentes, sino que se crean a partir de un PR en el repositorio Git de la aplicaciones y luego se eliminan un tiempo después (manualmente o mediante la recolección automática de basura).&lt;/p&gt;
&lt;h2 id=&#34;anotaciones-personalizadas-de-entrada&#34;&gt;Anotaciones Personalizadas de Entrada&lt;/h2&gt;
&lt;p&gt;Para obtener información sobre cómo agregar anotaciones personalizadas al controlador de entradas, consulte &lt;a href=&#34;https://jenkins-x.io/docs/resources/faq/using/#how-to-add-custom-annotations-to-ingress-controller&#34;&gt;¿Cómo agregar anotaciones personalizadas al controlador de Entradas?&lt;/a&gt;&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Diagrama</title>
      <link>https://jenkins-x.io/es/docs/concepts/diagram/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jenkins-x.io/es/docs/concepts/diagram/</guid>
      <description>
        
        
        &lt;p&gt;Existen varias arquitecturas basadas en cómo elige instalar Jenkins X. A continuación, le mostramos dos arquitecturas comunes.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&#34;https://jenkins-x.io/images/ArchitectureStaticJenkins.png&#34;/&gt;
&lt;figcaption&gt;
&lt;h5&gt;La arquitectura muestra un despliegue con una instancia estática de Jenkins&lt;/h5&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;figure&gt;
&lt;img src=&#34;https://jenkins-x.io/images/ArchitectureServerlessJenkins.png&#34;/&gt;
&lt;figcaption&gt;
&lt;h5&gt;La arquitectura muestra un despliegue sin servidor (serverless) utilizando los Pipelines de Tekton&lt;/h5&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;
      </description>
    </item>
    
    <item>
      <title>Docs: Funcionalidades</title>
      <link>https://jenkins-x.io/es/docs/concepts/features/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jenkins-x.io/es/docs/concepts/features/</guid>
      <description>
        
        
        &lt;h2 id=&#34;línea-de-comando&#34;&gt;Línea de Comando&lt;/h2&gt;
&lt;p&gt;Jenkins X viene con una útil y práctica herramienta de línea de comandos &lt;a href=&#34;https://jenkins-x.io/commands/jx/&#34;&gt;jx&lt;/a&gt; para:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://jenkins-x.io/docs/getting-started/setup/install/&#34;&gt;instalar Jenkins X&lt;/a&gt; dentro de un clúster de Kubernetes existente&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jenkins-x.io/docs/getting-started/setup/create-cluster/&#34;&gt;crear un nuevo cluster de Kubernetes&lt;/a&gt; e instalar Jenkins X dentro de él&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jenkins-x.io/docs/resources/guides/using-jx/creating/import/&#34;&gt;cargar/importar proyectos&lt;/a&gt; dentro de Jenkins X junto a su flujos de configuración CI/CD&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jenkins-x.io/developing/create-spring/&#34;&gt;crea nuevas aplicaciones Spring Boot&lt;/a&gt; las cuales son cargadas dentro de Jenkins X junto a sus flujos de configuración CI/CD&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;pipelines-automatizados&#34;&gt;Pipelines Automatizados&lt;/h2&gt;
&lt;p&gt;En lugar de tener que tener un conocimiento profundo de las partes internas de Jenkins Pipeline, Jenkins X configurará automáticamente pipelines (flujos de actividades) increíbles para que sus proyectos implementen completamente CI y CD utilizando las &lt;a href=&#34;https://jenkins-x.io/about/concepts/&#34;&gt;mejores prácticas de DevOps&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;entornos&#34;&gt;Entornos&lt;/h2&gt;
&lt;p&gt;Un &lt;em&gt;entorno&lt;/em&gt; es un lugar donde se despliegan las aplicaciones. Los desarrolladores a menudo hacen referencia a los entornos usando un nombre corto como &lt;code&gt;Testing, Staging/UAT or Production&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Con Jenkins X cada &lt;em&gt;equipo&lt;/em&gt; tiene sus propios Entornos. De forma predeterminada, Jenkins X crea los entornos &lt;code&gt;Staging&lt;/code&gt; y &lt;code&gt;Production&lt;/code&gt; para cada equipo, pero puede crear nuevos entornos a través de &lt;a href=&#34;https://jenkins-x.io/commands/jx_create_environment/&#34;&gt;jx create environment&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;También está el entorno &lt;code&gt;Dev&lt;/code&gt;, que es donde se instalan herramientas como Jenkins, Nexus o Prow y donde se ejecutan los pipelines de CI/CD.&lt;/p&gt;
&lt;p&gt;Utilizamos GitOps para gestionar la configuración y la versión de los recursos de Kubernetes que se despliegan en cada entorno. Por lo tanto, cada Entorno tiene su propio repositorio Git que contiene todos los Helm Charts, sus versiones y la configuración para que las aplicaciones se ejecuten en el entorno.&lt;/p&gt;
&lt;p&gt;Un Entorno se asigna a un espacio de nombres (namespace) en un clúster de Kubernetes. Cuando los PR son mezclados en el repositorio Git del entorno, se desencadena la ejecución de los pipelines para aplicar los cambias a través de los Helms Charts en el namespace del entorno.&lt;/p&gt;
&lt;p&gt;Esto significa que tanto los desarrolladores como administradores pueden utilizar el mismo repositorio de Git para administrar todas las configuraciones y versiones de todas las aplicaciones y recursos para un entorno, por lo tanto, todos los cambios en el entorno se capturan en Git. De esta forma es fácil ver quién realizó los cambios y, lo que es más importante, es fácil revertir los cambios cuando sucedan cosas malas.&lt;/p&gt;
&lt;img src=&#34;https://jenkins-x.io/images/gitops.png&#34; class=&#34;img-thumbnail&#34;&gt;
&lt;h2 id=&#34;equipos&#34;&gt;Equipos&lt;/h2&gt;
&lt;p&gt;Un equipo en Jenkins X está representado por una instalación de Jenkins X en un namespace separado.&lt;/p&gt;
&lt;p&gt;Puede instalar Jenkins X en diferentes namespaces en el mismo clúster si lo desea utilizando el argumento &lt;code&gt;--namespace&lt;/code&gt; en la línea de comando &lt;a href=&#34;https://jenkins-x.io/commands/jx_create_cluster/&#34;&gt;jx create cluster&lt;/a&gt; o &lt;a href=&#34;https://jenkins-x.io/commands/deprecation/&#34;&gt;jx install&lt;/a&gt;. Tenga en cuenta que para admitir múltiples instalaciones de Jenkins X en el mismo clúster, debe &lt;a href=&#34;https://jenkins-x.io/news/helm-without-tiller/&#34;&gt;evitar Tiller si está utilizando helm 2.x&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;También puede utilizar la CLI &lt;a href=&#34;https://jenkins-x.io/commands/jx_create_team/&#34;&gt;jx create team&lt;/a&gt; para crear un nuevo &lt;code&gt;Team&lt;/code&gt; &lt;a href=&#34;https://jenkins-x.io/docs/reference/components/custom-resources/&#34;&gt;Custom Resource&lt;/a&gt;. Al utilizar este comando el controlador de equipos creará, en segundo plano, una nueva instalación de Jenkins X en los namespaces del equipo, reutilizando de forma predeterminada el mismo nexus y registro de docker.&lt;/p&gt;
&lt;p&gt;Lea la &lt;a href=&#34;https://jenkins-x.io/docs/resources/guides/managing-jx/common-tasks/config/&#34;&gt;guía de configuración&lt;/a&gt; para ampliar los detalles sobre cómo compartir recursos como Nexus entre equipos.&lt;/p&gt;
&lt;h2 id=&#34;promoción&#34;&gt;Promoción&lt;/h2&gt;
&lt;p&gt;La promoción es implementada con GitOps generando una PR en el repositorio Git del entorno para que todos los cambios pasen por Git para su revisión, aprobación y para que cualquier cambio sea fácil de revertir.&lt;/p&gt;
&lt;p&gt;Cuando un nuevo cambio dentro del repositorio Git del entorno se mezcla con la rama master, se activa el pipeline para el entorno, el cual aplica los cambio a los recursos a través de helm; siempre utilizando el código del repositorio Git como única fuente de información.&lt;/p&gt;
&lt;p&gt;Los Pipelines para CD de Jenkins X automatizan la promoción de cambios de versión a través de cada Entorno que se configura con la propiedad &lt;em&gt;promotion strategy&lt;/em&gt; en &lt;code&gt;Auto&lt;/code&gt;. De forma predeterminada, el entorno &lt;code&gt;Staging&lt;/code&gt; utiliza la promoción automática y el entorno &lt;code&gt;Production&lt;/code&gt; utiliza la promoción manual.&lt;/p&gt;
&lt;p&gt;Para promover manualmente una versión de la aplicación hacia un entorno debes utilizar el comando &lt;a href=&#34;https://jenkins-x.io/developing/promote/&#34;&gt;jx promote&lt;/a&gt;.&lt;/p&gt;
&lt;img src=&#34;https://jenkins-x.io/images/overview.png&#34; class=&#34;img-thumbnail&#34;&gt;
&lt;h2 id=&#34;entornos-de-vista-previa&#34;&gt;Entornos de Vista Previa&lt;/h2&gt;
&lt;p&gt;Jenkins X le permite activar Entornos de Vista Previa para los PR, de esta forma podrá obtener rápida retroalimentación antes de mezclar los cambios en la rama master. Además de una rápida retroalimentación, esta funcionalidad le permite evitar la aprobación humana dentro de su pipeline de liberación para acelerar las entregas de cambios mezclados a master.&lt;/p&gt;
&lt;p&gt;Cuando el Entorno de Vista Previa esté en funcionamiento, Jenkins X comentará su PR con un enlace para que, con un solo clic, los miembros de su equipo puedan probar la vista previa.&lt;/p&gt;
&lt;img src=&#34;https://jenkins-x.io/images/pr-comment.png&#34; class=&#34;img-thumbnail&#34;&gt;
&lt;h2 id=&#34;retroalimentación&#34;&gt;Retroalimentación&lt;/h2&gt;
&lt;p&gt;Como puede ver arriba, Jenkins X agrega comentarios automáticamente en los PR cuando utilizar Entornos de Vista Previa.&lt;/p&gt;
&lt;p&gt;Si los comentarios del commit hacen referencia a los problemas (issues, p.ej. con el texto &lt;code&gt;fixes #123&lt;/code&gt;), los pipelines de Jenkins X generarán notas de la versión como las mostradas en los &lt;a href=&#34;https://github.com/jenkins-x/jx/releases&#34;&gt;jx releases&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Además, a medida que la versión (conjunto de nuevos commits) sea promovida en &lt;code&gt;Staging&lt;/code&gt; o &lt;code&gt;Production&lt;/code&gt;, recibirá comentarios automáticos sobre cada problema solucionado diciendo que el problema solucionado se encuentra disponible para su revisión en el correspondiente entorno. p.ej.&lt;/p&gt;
&lt;img src=&#34;https://jenkins-x.io/images/issue-comment.png&#34; class=&#34;img-thumbnail&#34;&gt;
&lt;h2 id=&#34;aplicaciones&#34;&gt;Aplicaciones&lt;/h2&gt;
&lt;p&gt;Una colección de las mejores herramientas de software empaquetadas con charts de helm vienen pre-integradas con Jenkins X, tales como: Nexus, ChartMuseum, Monocular, Prometheus, Grafana, etc.&lt;/p&gt;
&lt;h3 id=&#34;complementos&#34;&gt;Complementos&lt;/h3&gt;
&lt;p&gt;Algunas de estas aplicaciones están ajustadas; como: Nexus, ChartMuseum, Monocular. Otros se proporcionan como un &lt;code&gt;Addon&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Para instalar un complemento utilice el comando &lt;a href=&#34;https://jenkins-x.io/commands/jx_create_addon/&#34;&gt;jx create addon&lt;/a&gt;. p.ej.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;jx create addon grafana
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      </description>
    </item>
    
    <item>
      <title>Docs: Pipelines en Jenkins X</title>
      <link>https://jenkins-x.io/es/docs/concepts/jenkins-x-pipelines/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jenkins-x.io/es/docs/concepts/jenkins-x-pipelines/</guid>
      <description>
        
        
        &lt;p&gt;Hemos &lt;a href=&#34;https://jenkins-x.io/news/jenkins-x-next-gen-pipeline-engine/&#34;&gt;anunciado recientemente&lt;/a&gt; la incorporación de los &lt;strong&gt;Pipelines en Jenkins X&lt;/strong&gt;. Estos Pipelines son ejecuciones sin servidor basados en el motor de &lt;a href=&#34;https://tekton.dev/&#34;&gt;Tekton Pipelines&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Tekton es un proyecto open source diseñado como solución moderna nativa de la nube para ejecutar pipelines.&lt;/p&gt;
&lt;p&gt;El trabajo aquí todavía es experimental, pero nos encantaría recibir comentarios y ayuda de la comunidad para impulsarlo.&lt;/p&gt;
&lt;h2 id=&#34;probar-los-pipelines-de-jenkins-x&#34;&gt;Probar los Pipelines de Jenkins X&lt;/h2&gt;
&lt;p&gt;En este momento, para habilitar una instalación basada en Tekton, puede crear un nuevo clúster usando &lt;code&gt;jx&lt;/code&gt; junto con estos indicadores:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;jx create cluster gke --tekton
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;O bien, si desea participar en la próxima generación de Jenkins X con GitOps incorporado para su entorno de desarrollo, utilizando Tekton y Vault para el almacenamiento de Secretos, utilice el siguiente comando (solo funciona en GCP y AWS en este momento):&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;jx create cluster gke --ng
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;La experiencia general del desarrollador, los complementos CLI e IDE deberían funcionar como antes, ¡pero utilizando los Recursos Personalizados de &lt;a href=&#34;https://tekton.dev/&#34;&gt;Tekton Pipelines&lt;/a&gt; como maquinaria en lugar de crear un servidor Jenkins por equipo!&lt;/p&gt;
&lt;h2 id=&#34;utilizando-un-inicio-rápido&#34;&gt;Utilizando un Inicio Rápido&lt;/h2&gt;
&lt;p&gt;Una vez que se inicia su clúster, puede crear un nuevo inicio rápido, hemos estado usando el NodeJS de manera confiable.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;jx create quickstart
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Se crea un &lt;code&gt;prowjob&lt;/code&gt; (trabajo/ejecución de prow), un nuevo controlador pipelines prow vigila estos trabajos y cuando recibe un evento verificará si tiene una especificación &lt;code&gt;pipelinerun&lt;/code&gt; presente, si no, publicará el &lt;code&gt;prowjob&lt;/code&gt; en un nuevo servicio &lt;code&gt;pipelinerunner&lt;/code&gt; de Jenkins X que a su vez clona el repositorio que luego traducen a su &lt;code&gt;jenkins-x.yml&lt;/code&gt; en recursos comunes de Tekton Pipeline. Una vez que se crean, el controlador &lt;code&gt;tekton-pipeline-controller&lt;/code&gt; ejecuta las construcciones.&lt;/p&gt;
&lt;h2 id=&#34;diferencias-con-los-pipelines-de-jenkins&#34;&gt;Diferencias con los Pipelines de Jenkins&lt;/h2&gt;
&lt;p&gt;El Pipeline en Jenkins X utiliza un nuevo archivo &lt;code&gt;jenkins-x.yml&lt;/code&gt; que es YAML en lugar del fichero Groovy &lt;code&gt;Jenkinsfile&lt;/code&gt; utilizado por Jenkins.&lt;/p&gt;
&lt;p&gt;Sin embargo, todavía se están reutilizando los mismos paquetes de construcción reutilizables y de composición por detrás del telón. (Los paquetes de construcción de Jenkins X - &lt;a href=&#34;https://jenkins-x.io/docs/create-project/build-packs/&#34;&gt;build packs&lt;/a&gt; - en realidad están escritos en YAML en los Pipelines de Jenkins X).&lt;/p&gt;
&lt;p&gt;Una cosa que notará es que con los Pipelines de Jenkins X no necesitamos copiar/pegar un gran archivo &lt;code&gt;Jenkinsfile&lt;/code&gt; en el repositorio Git de cada aplicación; por lo general, el archivo &lt;code&gt;jenkins-x.yml&lt;/code&gt; generado es pequeño, como este:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;buildPack&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;maven&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;¡Eso es! Lo que eso significa básicamente es que, en tiempo de ejecución, el Pipeline de Jenkins X utilizará los paquetes de construcción - &lt;a href=&#34;https://jenkins-x.io/docs/create-project/build-packs/&#34;&gt;build packs&lt;/a&gt; - para generar el Pipeline de Tekton.&lt;/p&gt;
&lt;h2 id=&#34;personalizar-el-pipelines&#34;&gt;Personalizar el Pipelines&lt;/h2&gt;
&lt;p&gt;Tener paquetes de compilación - &lt;a href=&#34;https://jenkins-x.io/docs/create-project/build-packs/&#34;&gt;build packs&lt;/a&gt; - automatizados para hacer todo su CI+CD es bastante impresionante, ya que la mayoría de las veces sus microservicios se compilarán, probarán, empaquetarán, lanzarán y promocionarán de la misma manera. ¡CI+CD es a menudo un trabajo pesado indiferenciado que deberíamos automatizar!&lt;/p&gt;
&lt;p&gt;Sin embargo, hay veces que desea &lt;a href=&#34;https://jenkins-x.io/docs/create-project/build-packs/#pipelines&#34;&gt;personalizar un pipeline&lt;/a&gt; en particular (liberación, PR, característica, etc.) o modificar pasos involucrados dentro del &lt;a href=&#34;https://jenkins-x.io/docs/first-projects/build-packs/#life-cycles&#34;&gt;ciclo de vida&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Puede leer más sobre el &lt;a href=&#34;https://jenkins-x.io/docs/create-project/build-packs/#pipeline-extension-model&#34;&gt;modelo de extensión&lt;/a&gt; para descubrir todo lo que puede hacer. Básicamente, puede agregar pasos antes/después de cualquier ciclo de vida o reemplazar completamente un conjunto de ciclos de vida o incluso optar por salir del paquete de compilación por completo e alinear sus pipelines dentro de su &lt;code&gt;jenkins-x.yml&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Para una forma rápida de agregar un nuevo paso en el ciclo de vida de su pipeline, utilice el comando &lt;a href=&#34;https://jenkins-x.io/commands/deprecation/&#34;&gt;jx create step&lt;/a&gt;:&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&#34;https://jenkins-x.io/images/architecture/create-step.gif&#34; /&gt;
&lt;figcaption&gt;
&lt;h5&gt;Crea un nuevo paso en su Pipeline de Jenkins X a través del CLI&lt;/h5&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;También puede agregar o anular una variable de entorno en su pipeline a través del comando &lt;a href=&#34;https://jenkins-x.io/commands/jx_create_variable/&#34;&gt;jx create variable&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;modificaciones-en-vs-code&#34;&gt;Modificaciones en VS Code&lt;/h2&gt;
&lt;p&gt;Si está utilizando &lt;a href=&#34;https://code.visualstudio.com/&#34;&gt;VS Code&lt;/a&gt;, le recomendamos que instale la &lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=redhat.vscode-yaml&#34;&gt;extensión de lenguaje YAML&lt;/a&gt; de Red Hat.&lt;/p&gt;
&lt;p&gt;Esta extensión le permite editar archivos YAML con validación de esquema JSON de forma opcional.&lt;/p&gt;
&lt;p&gt;El esquema JSON de Jenkins X ya está registrado en &lt;a href=&#34;http://schemastore.org/json/&#34;&gt;schemastore.org&lt;/a&gt;, por lo tanto, editar su archivo &lt;code&gt;jenkins-x.yml&lt;/code&gt; en VS Code incluirá la finalización inteligente y la validación.&lt;/p&gt;
&lt;figure&gt;
&lt;embed src=&#34;https://jenkins-x.io/images/architecture/yaml-edit.mp4&#34; autostart=&#34;false&#34; height=&#34;400&#34; width=&#34;600&#34; /&gt;
&lt;figcaption&gt;
&lt;h5&gt;Editar el Pipeline de Jenkins X en VS Code&lt;/h5&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;Nos encantaría mejorar esta experiencia de usuario, por si te &lt;a href=&#34;https://jenkins-x.io/docs/contributing/&#34;&gt;apetece ayudar&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;modificaciones-en-idea&#34;&gt;Modificaciones en IDEA&lt;/h2&gt;
&lt;p&gt;Esto ya debería estar incluido de fábrica debido a que el esquema JSON de Jenkins X está registrado en &lt;a href=&#34;http://schemastore.org/json/&#34;&gt;schemastore.org&lt;/a&gt;, por lo que editar su archivo &lt;code&gt;jenkins-x.yml&lt;/code&gt; en IDEA incluirá la finalización inteligente y la validación.&lt;/p&gt;
&lt;p&gt;Nos encantaría mejorar esta experiencia de usuario, por si te &lt;a href=&#34;https://jenkins-x.io/docs/contributing/&#34;&gt;gustaría ayudar&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;variables-de-entorno-predeterminadas&#34;&gt;Variables de entorno predeterminadas&lt;/h2&gt;
&lt;p&gt;Las siguientes variables de entorno están disponibles para su uso en los pasos del Pipeline de Jenkins X:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Nombre&lt;/th&gt;
&lt;th&gt;Descripción&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;DOCKER_REGISTRY&lt;/td&gt;
&lt;td&gt;el servidor de registro de docker (p.ej. &lt;code&gt;docker.io&lt;/code&gt; o &lt;code&gt;gcr.io&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BUILD_NUMBER&lt;/td&gt;
&lt;td&gt;el número de construcción (1, 2, 3) comienza en &lt;code&gt;1&lt;/code&gt; para cada repo y rama&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PIPELINE_KIND&lt;/td&gt;
&lt;td&gt;el tipo de pipeline p.ej &lt;code&gt;release&lt;/code&gt; o &lt;code&gt;pullrequest&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PIPELINE_CONTEXT&lt;/td&gt;
&lt;td&gt;el contexto del pipeline si existen múltiples pipelines por PR (para diferenciar tests/governance/lint etc)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;REPO_OWNER&lt;/td&gt;
&lt;td&gt;el dueño del repositorio Git&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;REPO_NAME&lt;/td&gt;
&lt;td&gt;el nombre del repositorio Git&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JOB_NAME&lt;/td&gt;
&lt;td&gt;el nombre de la tarea que normalmente tiene este aspecto &lt;code&gt;$REPO_OWNER/$REPO_NAME/$BRANCH_NAME&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;APP_NAME&lt;/td&gt;
&lt;td&gt;el nombre de la applicación que normalmente es &lt;code&gt;$REPO_NAME&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BRANCH_NAME&lt;/td&gt;
&lt;td&gt;el nombre de la rama p.ej &lt;code&gt;master&lt;/code&gt; o &lt;code&gt;PR-123&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JX_BATCH_MODE&lt;/td&gt;
&lt;td&gt;indica a jx que utilice bash si el valor es &lt;code&gt;true&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;VERSION&lt;/td&gt;
&lt;td&gt;contiene el número de versión que ha sido liberada o la versión de la vista previa del PR&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BUILD_ID&lt;/td&gt;
&lt;td&gt;igual que &lt;code&gt;$BUILD_NUMBER&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JOB_TYPE&lt;/td&gt;
&lt;td&gt;la tipo de tarea de prow p.ej &lt;code&gt;presubmit&lt;/code&gt; para el PR o &lt;code&gt;postsubmit&lt;/code&gt; para la liberación&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PULL_BASE_REF&lt;/td&gt;
&lt;td&gt;la rama/referencia en Git&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PULL_BASE_SHA&lt;/td&gt;
&lt;td&gt;el SHA en Git que ha sido construido&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PULL_NUMBER&lt;/td&gt;
&lt;td&gt;para los PRs este será el número sin el prefijo &lt;code&gt;PR-&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PULL_REFS&lt;/td&gt;
&lt;td&gt;para combinar por lotes todas las referencias de Git&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Preguntas sobre Tecnología</title>
      <link>https://jenkins-x.io/es/docs/concepts/technology/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jenkins-x.io/es/docs/concepts/technology/</guid>
      <description>
        
        
        &lt;h2 id=&#34;qué-es-helm&#34;&gt;¿Qué es Helm?&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.helm.sh/&#34;&gt;helm&lt;/a&gt; es el administrador de paquetes de código abierto para Kubernetes.&lt;/p&gt;
&lt;p&gt;Funciona como cualquier otro administrador de paquetes (brew, yum, npm, etc) donde existen uno o más repositorios de donde se instalan los paquetes. Los paquetes en helm se llaman cartas náuticas (&lt;code&gt;charts&lt;/code&gt;) para seguir con el tema náutico en Kubernetes. Estos &lt;code&gt;charts&lt;/code&gt; pueden ser buscados, instalados y actualizados.&lt;/p&gt;
&lt;p&gt;Un &lt;a href=&#34;https://docs.helm.sh/developing_charts/#charts&#34;&gt;chart de helm es básicamente un conjunto de ficheros YAML versionados&lt;/a&gt; de Kubernetes que se puede instalar fácilmente en cualquier clúster.&lt;/p&gt;
&lt;p&gt;Helm permite la composición entre charts (un chart puede contener otro chart) a través del fichero &lt;code&gt;requirements.yaml&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;qué-es-skaffold&#34;&gt;¿Qué es Skaffold?&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/GoogleContainerTools/skaffold&#34;&gt;skaffold&lt;/a&gt; en una herramienta de código abierto para construir imágenes de docker en los clústeres de Kubernetes y luego desplegarlas/actualizarlas a través de &lt;code&gt;kubectl&lt;/code&gt; o &lt;code&gt;helm&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;El reto de construir imágenes de docker dentro del clúster de Kubernetes es seleccionar cómo hacerlo, porque existen varias estrategias a seguir para lograr el mismo objetivo, p.ej:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;utilizar el proceso (daemon) y socket local de docker del clúster de Kubernetes.&lt;/li&gt;
&lt;li&gt;utilizar el servicio de la nube como por ejemplo Google Cloud Builder&lt;/li&gt;
&lt;li&gt;utilizar un enfoque sin docker-daemon como es &lt;a href=&#34;https://github.com/GoogleContainerTools/kaniko&#34;&gt;kaniko&lt;/a&gt; que no necesita tener accesso al daemon de docker.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Lo bueno de skaffold es que abstrae su código o CLI de esos detalles; te permite definir la política para construir imágenes de docker en su archivo &lt;code&gt;skaffold.yaml&lt;/code&gt; para cambiar entre docker daemon, GCB o kaniko, etc.&lt;/p&gt;
&lt;p&gt;Skaffold también es realmente útil dentro de &lt;a href=&#34;https://jenkins-x.io/docs/reference/devpods/&#34;&gt;DevPods&lt;/a&gt; para hacer compilaciones incrementales rápidas si cambia el código fuente.&lt;/p&gt;
&lt;h2 id=&#34;cómo-se-compara-helm-con-skaffold&#34;&gt;¿Cómo se compara Helm con Skaffold?&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;helm&lt;/code&gt; le permite instalar/actualizar paquetes llamados charts que utilizan una o más imágenes de docker que se encuentran en algún registro de docker junto con algunos ficheros Kubernetes YAML para instalar/actualizar aplicaciones en un clúster de Kubernetes.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;skaffold&lt;/code&gt; es una herramienta para realizar construcciones de imágenes de docker y, opcionalmente, volver a desplegar aplicaciones a través de &lt;code&gt;kubectl&lt;/code&gt; o &lt;code&gt;helm&lt;/code&gt;, ya sea dentro del pipeline CI/CD o cuando se desarrolla localmente.&lt;/p&gt;
&lt;p&gt;Jenkins X utiliza &lt;code&gt;skaffold&lt;/code&gt; en sus pipelines de CI/CD para crear imágenes de docker. Luego se liberan versiones de imágenes de docker y charts de helm en cada mezcla de master. Luego se promueven los cambios a través de &lt;code&gt;helm&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;qué-es-exposecontroller&#34;&gt;¿Qué es exposecontroller?&lt;/h2&gt;
&lt;p&gt;Resulta que exponer servicios fuera del clúster de Kubernetes puede ser complejo. p.ej.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;¿Qué dominio usar?&lt;/li&gt;
&lt;li&gt;¿Debería usar TLS y generar certificados y asociarlos con los dominios?&lt;/li&gt;
&lt;li&gt;¿Estás usando OpenShift si es así, entonces quizás usar &lt;code&gt;Route&lt;/code&gt; es mejor que usar &lt;code&gt;Ingress&lt;/code&gt;?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Entonces, hemos simplificado los microservicios en Jenkins X delegando a un microservicio llamado &lt;a href=&#34;https://github.com/jenkins-x/exposecontroller&#34;&gt;exposecontroller&lt;/a&gt; el trabajo de ocuparse de estas cosas, como p.ej:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;exponer todos los &lt;code&gt;Service&lt;/code&gt; que tienen una etiqueta para indicar que están destinados a ser expuestos utilizando el clúster actual&lt;/li&gt;
&lt;li&gt;controla las reglas de exposición de los namespaces como el dominio&lt;/li&gt;
&lt;li&gt;utilizar o no TLS&lt;/li&gt;
&lt;li&gt;utilizar &lt;code&gt;Route&lt;/code&gt; o &lt;code&gt;Ingress&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Si mira dentro del repositorio Git de su entorno, puede observar que hay 2 &lt;code&gt;exposecontroller&lt;/code&gt; de forma predeterminada. Ambos &lt;code&gt;exposecontroller&lt;/code&gt; son &lt;a href=&#34;https://github.com/jenkins-x/default-environment-charts/blob/master/env/requirements.yaml&#34;&gt;charts de helm&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Estas 2 tareas son utilizadas de forma predeterminada para la generación o limpieza de recursos &lt;code&gt;Ingress&lt;/code&gt; para exponer los recursos &lt;code&gt;Services&lt;/code&gt; etiquetados para a los que desee acceder desde fuera del clúster. p.ej aplicación web o api rest.&lt;/p&gt;
&lt;p&gt;Puede optar por no utilizar exposecontroller si lo desea, simplemente no use las etiquetas de exposecontroller en sus servicios. Si lo desea, puede eliminar el trabajo de exposecontroller de un entorno, ¡aunque no podrá acceder a ninguno de nuestros QuickStarts desde fuera del clúster si lo hace!&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Version Stream</title>
      <link>https://jenkins-x.io/es/docs/concepts/version-stream/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jenkins-x.io/es/docs/concepts/version-stream/</guid>
      <description>
        
        
        &lt;p&gt;Jenkins X está compuesto por una gran cantidad de línea de comandos empaquetados, imágenes de docker y charts de helm, algunos de los cuales son lanzados por la comunidad Jenkins X y otros provienen del ecosistema de código abierto más amplio.&lt;/p&gt;
&lt;p&gt;Para mejorar la estabilidad de Jenkins X cuando muchos paquetes y charts están cambiando todo el tiempo, hemos introducido el Flujo de versiones de Jenkins X, &lt;code&gt;Version Stream&lt;/code&gt;.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&#34;https://jenkins-x.io/images/jx-version-stream-v1.png&#34;/&gt;
&lt;figcaption&gt;
&lt;h5&gt;El diagrama muestra cómo se propagará una nueva versión JX a través de los componentes.&lt;/h5&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h2 id=&#34;cómo-funciona&#34;&gt;¿Cómo funciona?&lt;/h2&gt;
&lt;p&gt;El flujo de versiones (&lt;code&gt;Version Stream&lt;/code&gt;) se almacena en el repositorio Git &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-versions&#34;&gt;jenkins-x/jenkins-x-versions&lt;/a&gt; y almacena la versión estable de todos los paquetes y charts utilizados por Jenkins X.&lt;/p&gt;
&lt;p&gt;Cuando ejecuta un comando, como por ejemplo &lt;a href=&#34;https://jenkins-x.io/es/docs/getting-started/setup/create-cluster/&#34;&gt;crear un clúster&lt;/a&gt;, &lt;a href=&#34;https://jenkins-x.io/docs/resources/guides/managing-jx/common-tasks/install-on-cluster/&#34;&gt;instalar en un clúster existente&lt;/a&gt; o ejecutar el comando &lt;a href=&#34;https://jenkins-x.io/commands/jx_upgrade/&#34;&gt;jx upgrade&lt;/a&gt;, el comando &lt;code&gt;jx&lt;/code&gt; se asegurará de que tenga un clon local del repositorio Git &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-versions&#34;&gt;jenkins-x/jenkins-x-versions&lt;/a&gt; actualizado. Después de clonado el repositorio Jenkins X se descarga la versión estable de los charts y paquetes descritos en el, o registrará una advertencia si la versión no lo es.&lt;/p&gt;
&lt;p&gt;La versión &lt;a href=&#34;https://github.com/jenkins-x/jx&#34;&gt;jx&lt;/a&gt; por ahora se publica como una &lt;a href=&#34;https://help.github.com/en/articles/creating-releases&#34;&gt;versión preliminar&lt;/a&gt;. Cada versión de jx se actualiza solamente cuando una nueva versión llega con éxito al repositorio jenkins-x-versions. Cada nueva versión es sometida a rondas de pruebas BDD (&lt;em&gt;consulte el diagrama anterior para obtener más información&lt;/em&gt;) antes de ser marcadas como listas para liberar.&lt;/p&gt;
&lt;h2 id=&#34;cómo-actualizamos-el-flujo-de-versiones&#34;&gt;¿Cómo actualizamos el Flujo de Versiones?&lt;/h2&gt;
&lt;p&gt;Utilizamos GitOps y CI/CD para administrar el Flujo de Versiones (&lt;code&gt;Version Stream&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;A medida que se lanzan nuevos paquetes o charts, generamos PR en el repositorio git &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-versions&#34;&gt;jenkins-x/jenkins-x-versions&lt;/a&gt;. Luego activamos nuestras &lt;a href=&#34;https://github.com/jenkins-x/bdd-jx&#34;&gt;pruebas BDD&lt;/a&gt; a través de &lt;a href=&#34;https://jenkins-x.io/commands/jx_step_bdd/&#34;&gt;jx step bdd&lt;/a&gt; y verificamos que la nueva versión del chart/paquete funcione antes de mezclar los cambios. Actualmente activamos manualmente las pruebas de BDD a través del comentario &lt;code&gt;/test this&lt;/code&gt;, pero esperamos pasar a la activación periódica de las pruebas de BDD (por ejemplo, una vez al día).&lt;/p&gt;
&lt;p&gt;Las personas que aprueban los PR también pueden optar por ejecutar sus propias pruebas manuales en las PR si lo desean.&lt;/p&gt;
&lt;p&gt;Al completar con éxito todas las pruebas BDD ejecutadas en el PR, mezclará el cambio y ejecutará una actualización de todas las dependencias jx (homebrew-jx, jx-docs, jx-tutorial y dev-env-base).&lt;/p&gt;
&lt;h2 id=&#34;creando-pull-requests-pr&#34;&gt;Creando Pull Requests (PR)&lt;/h2&gt;
&lt;p&gt;Tenemos un simple comando CLI &lt;a href=&#34;https://jenkins-x.io/commands/jx_step_create_pullrequest_versions/&#34;&gt;jx step create pullrequest versions&lt;/a&gt; que se puede utilizar para generar automáticamente solicitudes de extracción (PR) en el repositorio git &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-versions&#34;&gt;jenkins-x/jenkins-x-versions&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Si eres el responsable de un chart de entrada que utiliza Jenkins X, sería increíble agregar este comando al final de su pipeline de liberación para generar un PR y que de esa forma podamos actualizar Jenkins X para utilizar su nueva versión (después que las pruebas BDD hayan pasado correctamente):&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;jx step create pullrequest versions -n mychartName -v 1.2.3
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;donde mychartName es el nombre de gráfico completo que utiliza el prefijo de repositorio remoto. p.ej. jenkins-x / prow es el nombre del gráfico de proa mantenido en el repositorio de gráficos jenkins-x.&lt;/p&gt;
&lt;p&gt;donde &lt;code&gt;mychartName&lt;/code&gt; es el nombre completo del chart donde se incluye el prefijo para el repositorio remoto. p.ej &lt;code&gt;jenkins-x/prow&lt;/code&gt; sería &lt;code&gt;prow&lt;/code&gt; el nombre del chart que se le da manteminiento y &lt;code&gt;jenkins-x&lt;/code&gt; el repositorio del chart.&lt;/p&gt;
&lt;h3 id=&#34;actualizaciones-periódicas&#34;&gt;Actualizaciones Periódicas&lt;/h3&gt;
&lt;p&gt;No siempre es fácil/posible actualizar los pipelines de entrada para impulsar los cambios de versión a Jenkins X a través de los PRs. Por lo tanto, puede configurar tareas periódicas para buscar actualizaciones de versión para todos los charts o para charts que coincidan con una expresión regular.&lt;/p&gt;
&lt;p&gt;p.ej para actualizar las versiones de todos los charts incluidos en &lt;code&gt;jenkins-x&lt;/code&gt; utilice el siguiente comando:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;jx step create version pr -f &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;jenkins-x/*&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;ejecutar-los-tests-bdd&#34;&gt;Ejecutar los tests BDD&lt;/h2&gt;
&lt;p&gt;Desde un clon de Git master o un PR, puede ejecutar las pruebas BDD contra la combinación de la versión del PR utilizando el comando &lt;a href=&#34;https://jenkins-x.io/commands/jx_step_bdd/&#34;&gt;jx step bdd&lt;/a&gt; y especificando &lt;code&gt;--dir .&lt;/code&gt; para el directorio del clon.&lt;/p&gt;
&lt;p&gt;p.ej. puede ejecutar las pruebas BDD usted mismo a través de &amp;hellip;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git clone https://github.com/jenkins-x/jenkins-x-versions.git
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# env vars for the git / jenkins secrets&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;export GIT_PROVIDER&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;github
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;export GIT_PROVIDER_URL&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;https://github.com
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;export BUILD_NUMBER&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;export JENKINS_CREDS_PSW&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;mypassword
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;export GIT_CREDS_PSW&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;XXXXXXX
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;export GIT_USER&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;YYYYY
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;jx step bdd --dir . --config jx/bdd/staticjenkins.yaml --gopath /tmp --git-provider&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;$GIT_PROVIDER --git-provider-url&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;$GIT_PROVIDER_URL --git-username $GIT_USER --git-owner $GIT_USER --git-api-token $GIT_CREDS_PSW --default-admin-password $JENKINS_CREDS_PSW --no-delete-app --no-delete-repo --tests test-create-spring
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Los diversos archivos YAML en la carpeta &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-versions/tree/master/jx/bdd&#34;&gt;jx/bdd&lt;/a&gt; contienen una selección de diferentes grupos configuraciones que se pueden utilizar.&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>
