<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jenkins X - Cloud Native CI/CD Built On Kubernetes – Componentes en Jenkins X</title>
    <link>https://jenkins-x.io/es/docs/reference/components/</link>
    <description>Recent content in Componentes en Jenkins X on Jenkins X - Cloud Native CI/CD Built On Kubernetes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>es-ES</language>
    
	  <atom:link href="https://jenkins-x.io/es/docs/reference/components/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: Recursos Personalizados</title>
      <link>https://jenkins-x.io/es/docs/reference/components/custom-resources/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jenkins-x.io/es/docs/reference/components/custom-resources/</guid>
      <description>
        
        
        &lt;p&gt;Kubernetes proporciona un mecanismo de extensión llamado &lt;a href=&#34;https://kubernetes.io/docs/concepts/api-extension/custom-resources/&#34;&gt;Recursos Personalizados&lt;/a&gt; que permite que los microservicios extiendan la plataforma Kubernetes para resolver problemas de orden superior.&lt;/p&gt;
&lt;p&gt;Entonces, en Jenkins X, hemos agregado una serie de Recursos Personalizados para ayudar a ampliar Kubernetes para admitir CI/CD.&lt;/p&gt;
&lt;p&gt;También puede &lt;a href=&#34;https://jenkins-x.io/apidocs/&#34;&gt;navegar por la Referencia de API de Recursos Personalizados&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;environments&#34;&gt;Environments&lt;/h2&gt;
&lt;p&gt;Jenkins X admite de forma nativa los &lt;a href=&#34;https://jenkins-x.io/es/about/concepts/features/#entornos&#34;&gt;entornos&lt;/a&gt; que le permiten ser definidos para su equipo y luego consultarlos a través de &lt;a href=&#34;https://jenkins-x.io/commands/jx_get_environments/&#34;&gt;jx get environments&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;jx get environments
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Durante el funcionamiento de ese comando se utiliza el recurso personalizado de Kubernetes &lt;code&gt;Environments&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Por lo tanto, también puede consultar los entornos a través de &lt;a href=&#34;https://kubernetes.io/docs/reference/kubectl/overview/&#34;&gt;kubectl&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kubectl get environments
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;O editarlos vía &lt;code&gt;YAML&lt;/code&gt; directamente si lo desea:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kubectl edit env staging
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;aunque puede preferir el comando &lt;a href=&#34;https://jenkins-x.io/commands/jx_edit_environment/&#34;&gt;jx edit environment&lt;/a&gt;, que es más fácil.&lt;/p&gt;
&lt;h2 id=&#34;release&#34;&gt;Release&lt;/h2&gt;
&lt;p&gt;Los pipelines de Jenkins X generan el recurso personalizado &lt;code&gt;Release&lt;/code&gt; que podemos utilizar para realizar un seguimiento de:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;qué versión, etiqueta Git y URL Git se asignan a una versión en Kubernetes/Helm&lt;/li&gt;
&lt;li&gt;qué URL y registro pipeline de Jenkins se usaron para realizar el lanzamiento&lt;/li&gt;
&lt;li&gt;qué compromisos, problemas y PR formaron parte de cada lanzamiento para que podamos implementar los &lt;a href=&#34;https://jenkins-x.io/es/about/concepts/features/#retroalimentaci%C3%B3n&#34;&gt;comentarios a medida que los problemas se solucionan en Staging/Production&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;sourcerepository&#34;&gt;SourceRepository&lt;/h2&gt;
&lt;p&gt;Esto almacena información sobre los repositorios de código fuente que Jenkins X está configurado para construir.&lt;/p&gt;
&lt;p&gt;Es creado por &lt;code&gt;jx import&lt;/code&gt; y &lt;code&gt;jx create quickstart&lt;/code&gt; y se elimina cada vez que se invoca una &lt;code&gt;jx delete application&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;scheduler&#34;&gt;Scheduler&lt;/h2&gt;
&lt;p&gt;Esto se utiliza para definir una configuración para uno o más &lt;code&gt;SourceRepository&lt;/code&gt; y &lt;code&gt;jx boot&lt;/code&gt; lo usa para generar la configuración de Prow.&lt;/p&gt;
&lt;p&gt;Esto le permite configurar un &lt;code&gt;Scheduler&lt;/code&gt; predeterminado para un equipo y luego no tiene que tocar su configuración de Prow en absoluto; Todos los proyectos importados/creados heredarán del &lt;code&gt;Scheduler&lt;/code&gt; predeterminado.&lt;/p&gt;
&lt;p&gt;O cuando realiza &lt;code&gt;jx import&lt;/code&gt; o &lt;code&gt;jx create quickstart&lt;/code&gt; puede pasar el parámetro de línea de comando &lt;code&gt;--scheduler&lt;/code&gt; para usar un programador específico.&lt;/p&gt;
&lt;h2 id=&#34;pipelineactivity&#34;&gt;PipelineActivity&lt;/h2&gt;
&lt;p&gt;Este recurso almacena el estado del pipeline en términos de etapas de pipelines de Jenkins, más la &lt;a href=&#34;https://jenkins-x.io/es/about/concepts/features/#promoci%C3%B3n&#34;&gt;actividad de promoción&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Este recurso también lo utiliza el comando &lt;a href=&#34;https://jenkins-x.io/commands/jx_get_activities/&#34;&gt;jx get activities&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;team&#34;&gt;Team&lt;/h2&gt;
&lt;p&gt;El recurso personalizado &lt;code&gt;Team&lt;/code&gt; se crea mediante el comando &lt;a href=&#34;https://jenkins-x.io/commands/jx_create_team/&#34;&gt;jx create team&lt;/a&gt; y el controlador &lt;code&gt;team controller&lt;/code&gt; lo utiliza para observar los nuevos recursos &lt;code&gt;Team&lt;/code&gt; para luego crear una instalación de Jenkins X en el namespace del &lt;code&gt;teams&lt;/code&gt;. Para obtener más información sobre los equipos, consulte &lt;a href=&#34;https://jenkins-x.io/es/about/concepts/features/#equipos&#34;&gt;la función del equipo&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;user&#34;&gt;User&lt;/h3&gt;
&lt;p&gt;El recurso personalizado &lt;code&gt;User&lt;/code&gt; se utiliza para admitir RBAC en los distintos &lt;a href=&#34;https://jenkins-x.io/es/about/concepts/features/#entornos&#34;&gt;entornos&lt;/a&gt; y &lt;a href=&#34;https://jenkins-x.io/about/concepts/features/#preview-environments&#34;&gt;vistas previas de entornos&lt;/a&gt; en equipos.&lt;/p&gt;
&lt;p&gt;También lo utilizan el comando &lt;a href=&#34;https://jenkins-x.io/commands/jx_edit_userroles/&#34;&gt;jx edit userroles&lt;/a&gt; para cambiar los roles de usuario.&lt;/p&gt;
&lt;h2 id=&#34;environmentrolebinding&#34;&gt;EnvironmentRoleBinding&lt;/h2&gt;
&lt;p&gt;El recurso &lt;code&gt;EnvironmentRoleBinding&lt;/code&gt; es como el recurso estándar de Kubernetes &lt;a href=&#34;https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/#rolebinding-v1-rbac-authorization-k8s-io&#34;&gt;RoleBinding&lt;/a&gt;, pero permite la asignación de un rol a múltiples &lt;a href=&#34;https://jenkins-x.io/es/about/concepts/features/#entornos&#34;&gt;entornos&lt;/a&gt; y &lt;a href=&#34;https://jenkins-x.io/about/concepts/features/#preview-environments&#34;&gt;vistas previas de entornos&lt;/a&gt; en un equipo mediante el uso de un selector de entornos en el que se vinculan roles.&lt;/p&gt;
&lt;p&gt;Esto facilita la vinculación de un &lt;code&gt;Role&lt;/code&gt; a todos los entornos, a todos los entornos de vista previa o a ambos o a un conjunto determinado de usuarios.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Decisiones</title>
      <link>https://jenkins-x.io/es/docs/reference/components/decisions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jenkins-x.io/es/docs/reference/components/decisions/</guid>
      <description>
        
        
        &lt;h1 id=&#34;decisiones&#34;&gt;Decisiones&lt;/h1&gt;
&lt;p&gt;Jenkins X es una experiencia de desarrollo basada en opiniones de expertos, aquí explicaremos los antecedentes y las decisiones que hemos tomado para ayudar a explicar las razones de estas opiniones. También puede consultar la página &lt;a href=&#34;https://jenkins-x.io/docs/reference/components/decisions/&#34;&gt;Accelerate&lt;/a&gt; para obtener detalles sobre cómo Jenkins X implementa las competencias recomendadas por este libro.&lt;/p&gt;
&lt;h2 id=&#34;kubernetes&#34;&gt;Kubernetes&lt;/h2&gt;
&lt;p&gt;Primero es por qué Jenkins X se centra exclusivamente en Kubernetes y solo está destinado a ejecutarse en él.&lt;/p&gt;
&lt;p&gt;Kubernetes ha ganado las guerras de la nube, cada proveedor importante de la nube ahora es compatible con Kubernetes o está trabajando activamente en una solución de Kubernetes. Google, Microsoft, Amazon, Red Hat, Oracle, IBM, Alibaba, Digital Ocean, Docker, Mesos y Cloud Foundry, por nombrar algunos. Ahora tenemos una plataforma de despliegues hacia donde apuntar y para desarrollar aplicaciones portables de primera clase.&lt;/p&gt;
&lt;p&gt;El ecosistema de Kubernetes es rico en innovación y con una comunidad vibrante, innovadora y diversa de código abierto que invita sola, la cual sugiere grandes cosas para todos los involucrados.&lt;/p&gt;
&lt;p&gt;Jenkins X recomienda usar clústeres de Kubernetes administrados en la nube pública siempre que sea posible. GKE, AKS y EKS ofrecen servicios gestionados de Kubernetes, lo que reduce drásticamente el riesgo de instalar, actualizar y mantener su clúster de Kubernetes para que pueda concentrarse en desarrollar un código increíble.&lt;/p&gt;
&lt;p&gt;es decir, permite que las personas que saben cómo ejecutar contenedores y administrar clústeres a escala puedan concentrarse en agregar valor a su negocio.&lt;/p&gt;
&lt;h2 id=&#34;draft&#34;&gt;Draft&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://draft.sh&#34;&gt;Draft&lt;/a&gt; tiene algunas capacidades, pero Jenkins X solo usa la función de detección de idioma y la creación de paquetes. Jenkins X mantiene sus propios &lt;a href=&#34;https://github.com/jenkins-x-buildpacks/jenkins-x-kubernetes&#34;&gt;paquetes de draft&lt;/a&gt;  diseñados para ejecutarse con Jenkins X.&lt;/p&gt;
&lt;p&gt;Draft proporciona una excelente manera de iniciar un proyecto de código fuente con el paquete necesario para ejecutar la aplicación en Kubernetes.&lt;/p&gt;
&lt;p&gt;El proyecto Draft vino de Deis, que fue adquirida por Microsoft y continúa invirtiendo y evolucionando su historia de desarrollador de Kubernetes.&lt;/p&gt;
&lt;h2 id=&#34;helm&#34;&gt;Helm&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://helm.sh&#34;&gt;Helm&lt;/a&gt; proporciona el paquete de plantillas para ejecutar aplicaciones en Kubernetes. Hemos recibido comentarios mixtos de nuestro uso de Helm. Desde nuestra experiencia, poder crear plantillas y componer múltiples Helm Charts juntos ha sido un hallazgo muy bien recibido. Esto condujo a nuestro uso de Helm para componer, instalar y actualizar entornos completos y poder anteponer valores fácilmente como el número de réplicas o los límites de recursos de aplicaciones por entorno, por ejemplo.&lt;/p&gt;
&lt;p&gt;Las plantillas OpenShift tenían como objetivo hacer algo similar, sin embargo, son específicas de OpenShift.&lt;/p&gt;
&lt;p&gt;Muchas de las preocupaciones con Helm se están abordando con la actualización de la versión principal de Helm 3. Eliminar el uso de Tiller, el componente del lado del servidor de Helm, es una gran victoria, ya que se considera inseguro debido a los permisos elevados que necesita para ejecutarse. Jenkins X &lt;a href=&#34;https://jenkins-x.io/docs/reference/components/helm3/&#34;&gt;proporciona una forma&lt;/a&gt; de usar la versión beta de Helm 3 para las personas que deseen probar esto en su lugar, lo estamos utilizando nosotros mismos y hasta ahora está funcionando muy bien. Si hay problemas, nos gustaría enviar comentarios al proyecto Helm para que podamos ayudarlos a llegar a GA antes.&lt;/p&gt;
&lt;p&gt;El proyecto Helm vino de Deis, que fue adquirido por Microsoft y continúa invirtiendo y evolucionando su historia de desarrollador de Kubernetes.&lt;/p&gt;
&lt;h2 id=&#34;skaffold&#34;&gt;Skaffold&lt;/h2&gt;
&lt;p&gt;Jenkins X utiliza &lt;a href=&#34;https://github.com/GoogleContainerTools/skaffold&#34;&gt;Skaffold&lt;/a&gt; para realizar las acciones de construcción y empuje de imagen en un pipeline. Skaffold nos permite implementar diferentes servicios de creación de imágenes y de registros como &lt;a href=&#34;https://cloud.google.com/container-builder/&#34;&gt;Google Container Builder&lt;/a&gt;, &lt;a href=&#34;https://github.com/Azure/acr-builder&#34;&gt;Azure Container Builder&lt;/a&gt; y &lt;a href=&#34;https://aws.amazon.com/ecr/&#34;&gt;ECR&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Para las personas que no trabajan en una nube pública con el generador de contenedores o los servicios de registro, Skaffold también puede trabajar con &lt;a href=&#34;https://github.com/GoogleContainerTools/kaniko&#34;&gt;kaniko&lt;/a&gt;, esto permite a los pipelines construir imágenes de Docker utilizando contenedores sin raíz. Esto es significativamente más seguro que montar el socket de Docker desde cada nodo en el clúster.&lt;/p&gt;
&lt;h2 id=&#34;jenkins&#34;&gt;Jenkins&lt;/h2&gt;
&lt;p&gt;Jenkins, ¿por qué una gran JVM que no está altamente disponible? Puede parecer una sorpresa ésta selección como el motor de pipelines para usar en la nube, sin embargo, la adopción de Jenkins por parte de los desarrolladores y la comunidad que tiene significa que es ideal para usar y evolucionar su propia historia nativa de la nube. Jenkins X ya genera definiciones de recursos personalizados de Kubernetes para actividades en los pipelines que utilizan nuestras las herramientas IDE y CLI en lugar de consultar a Jenkins. Almacenaremos construcciones y ejecuciones de Jenkins en Kubernetes en lugar de en &lt;code&gt;$JENKINS_HOME&lt;/code&gt;, lo que significa que podemos escalar los maestros de Jenkins. También estamos cambiando a Prow para interceptar eventos de webhook de Git en lugar de utilizar Jenkins, esto significa que podemos tener una solución altamente disponible, así como entregar la programación de construcciones a Kubernetes.&lt;/p&gt;
&lt;p&gt;TL;DR estamos moviendo muchas de las funcionalidades del master de Jenkins a la plataforma Kubernetes.&lt;/p&gt;
&lt;p&gt;Tomar este enfoque también significa que podremos habilitar otros motores de pipelines en el futuro.&lt;/p&gt;
&lt;h2 id=&#34;prow&#34;&gt;Prow&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/test-infra/tree/master/prow&#34;&gt;Prow&lt;/a&gt; maneja eventos Git y puede desencadenar flujos de trabajo en Kubernetes.&lt;/p&gt;
&lt;p&gt;Prow puede ejecutarse en un modo de alta disponibilidad donde existen múltiples pods para una URL de entrada de webhook. A diferencia de Jenkins, si realiza una actualización, Jenkins tiene un tiempo de inactividad en el que se pueden perder los eventos de webhook. Esto está en nuestros planes futuros y esperamos tenerlo disponible pronto.&lt;/p&gt;
&lt;h2 id=&#34;nexus&#34;&gt;Nexus&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://help.sonatype.com/repomanager3&#34;&gt;Nexus&lt;/a&gt; es una JVM con sobrepeso que recientemente se mudó a OSGi, sin embargo, hace el trabajo que necesitamos. Dependencias de caché para compilaciones más rápidas y proporciona un repositorio compartido donde los equipos pueden compartir sus artefactos liberados.&lt;/p&gt;
&lt;p&gt;Si alguien desarrollara un servidor de repositorio de artefactos de código abierto en un lenguaje más amigable para la nube como Go, entonces Jenkins X probablemente cambiaría para ahorrar en facturas en la nube.&lt;/p&gt;
&lt;p&gt;En este momento, Jenkins X no utiliza el registro de Docker de Nexus. La razón principal fue que necesitábamos hacer un trabajo para configurar las definiciones de pod con secretos de extracción de imágenes para que podamos utilizar el registro autenticado. Sin embargo, nuestro enfoque recomendado es cambiar al uso de registros de proveedores de nube nativos como &lt;a href=&#34;https://aws.amazon.com/ecr/&#34;&gt;ECR de Amazon&lt;/a&gt;, &lt;a href=&#34;https://cloud.google.com/container-registry/&#34;&gt;Google Container Registry&lt;/a&gt; o DockerHub, por ejemplo, con la ayuda de Skaffold.&lt;/p&gt;
&lt;h2 id=&#34;docker-registry&#34;&gt;Docker registry&lt;/h2&gt;
&lt;p&gt;Como se indicó anteriormente, no tenemos la intención de usar &lt;a href=&#34;https://github.com/kubernetes/charts/tree/master/stable/docker-registry&#34;&gt;este registro&lt;/a&gt; a largo plazo, ya que preferimos usar registros de proveedores de la nube como &lt;a href=&#34;https://aws.amazon.com/ecr/&#34;&gt;ECR de Amazon&lt;/a&gt;, &lt;a href=&#34;https://cloud.google.com/container-registry/&#34;&gt;Google Container Registry&lt;/a&gt; o Dockerhub, por ejemplo, con la ayuda de Skaffold.&lt;/p&gt;
&lt;h2 id=&#34;chartmuseum&#34;&gt;ChartMuseum&lt;/h2&gt;
&lt;p&gt;Al momento de crear Jenkins X, había pocas opciones de cómo publicar Helm Charts, la comunidad de Kubernetes usa páginas de GitHub, pero queríamos encontrar una solución que funcione para las personas que usan cualquier proveedor de Git. &lt;a href=&#34;https://github.com/kubernetes-helm/chartmuseum&#34;&gt;ChartMuseum&lt;/a&gt; está escrito en Go, por lo que funciona bien en la nube, admite múltiples almacenamiento en la nube y funciona muy bien con Monocular.&lt;/p&gt;
&lt;h2 id=&#34;monocular&#34;&gt;Monocular&lt;/h2&gt;
&lt;p&gt;Usamos &lt;a href=&#34;https://github.com/kubernetes-helm/monocular&#34;&gt;Monocular&lt;/a&gt; para descubrir las aplicaciones publicadas de nuestros equipos, podríamos usar KubeApps de forma predeterminada si la comunidad lo prefiere, pero habilitaremos KubeApps como complemento independientemente.&lt;/p&gt;
&lt;h2 id=&#34;git&#34;&gt;Git&lt;/h2&gt;
&lt;p&gt;Jenkins X solo trabaja con Git. Hay muchas dependencias e implementaciones de clientes que Jenkins X ya necesita admitir para diferentes proveedores de Git, no escuchamos suficiente demanda para admitir otros sistemas de control de versiones, por lo que por ahora Jenkins X está vinculado a Git.&lt;/p&gt;
&lt;h2 id=&#34;programming-languages&#34;&gt;Programming languages&lt;/h2&gt;
&lt;p&gt;Jenkins X tiene como objetivo ayudar a proporcionar el nivel adecuado de comentarios para que los desarrolladores entiendan cómo funcionan sus aplicaciones y brindarles formas fáciles de experimentar con otros lenguajes que puedan adaptarse mejor a la función y a ejecutarse en la nube. Por ejemplo, hay muchas organizaciones basadas en Java que solo saben cómo escribir, ejecutar y mantener aplicaciones Java. Java es extremadamente intensivo en recursos en comparación con Golang, Rust, Swift, NodeJS, por nombrar algunos, esto genera facturas en la nube mucho más altas cada mes. Con Jenkins X, nuestro objetivo es ayudar a los desarrolladores a experimentar con otras opciones utilizando inicios rápidos y complementos de métricas como Grafana y Prometheus para ver cómo se comportan en la nube.&lt;/p&gt;
&lt;p&gt;Por ejemplo, cualquier microservicio nuevo que creemos en el proyecto Jenkins X tiende a estar en Golang o NodeJS dado el enorme efecto que tiene en nuestra facturación en la nube. Lleva tiempo cambiar a un nuevo lenguaje de programación, pero con Jenkins X esperamos poder mitigar un gran riesgo utilizando inicios rápidos, CI/CD automatizados y una forma relativamente consistente de trabajar en todos los idiomas.&lt;/p&gt;
&lt;h3 id=&#34;maven&#34;&gt;Maven&lt;/h3&gt;
&lt;p&gt;Maven tiene algunas herramientas que mucha gente está acostumbrada a usar y que no se adaptan particularmente bien al CD. Por ejemplo, el &lt;a href=&#34;http://maven.apache.org/maven-release/maven-release-plugin/&#34;&gt;plugin de liberación de Maven&lt;/a&gt; versionará un proyecto y se comprometerá directamente a dominar la nueva versión SNAPSHOT que en el mundo de CD desencadenaría otra versión que resultaría en un bucle recursivo.&lt;/p&gt;
&lt;p&gt;Para proyectos Java, Jenkins X usa la versión &lt;a href=&#34;https://www.mojohaus.org/versions-maven-plugin/set-mojo.html&#34;&gt;maven version:set plugin&lt;/a&gt; para actualizar todos los poms en un proyecto usando la próxima versión de lanzamiento siguiendo el paso #Versioning mencionado anteriormente.&lt;/p&gt;
&lt;p&gt;Si se necesita un nuevo incremento de versión mayor o menor, los usuarios pueden crear una nueva etiqueta Git con el nuevo número mayor/menor y Jenkins X lo respetará. Alternativamente, puede actualizar el padre &lt;code&gt;pom.xml&lt;/code&gt; y cualquier archivo pom hijo él mismo y Jenkins X detectará y usará la nueva versión mayor o menor.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Paquetes de Compilación</title>
      <link>https://jenkins-x.io/es/docs/reference/components/build-packs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jenkins-x.io/es/docs/reference/components/build-packs/</guid>
      <description>
        
        
        &lt;p&gt;Usamos paquetes de compilación de estilo &lt;a href=&#34;https://draft.sh/&#34;&gt;draft&lt;/a&gt; para diferentes lenguajes, tiempos de ejecución y herramientas de compilación para agregar los archivos de configuración necesarios a los proyectos a medida que los &lt;a href=&#34;https://jenkins-x.io/docs/resources/guides/using-jx/creating/import/&#34;&gt;importamos&lt;/a&gt; o los &lt;a href=&#34;https://jenkins-x.io/docs/resources/guides/using-jx/common-tasks/create-spring/&#34;&gt;creamos&lt;/a&gt; para que podamos compilarlos e desplegarlos en Kubernetes.&lt;/p&gt;
&lt;p&gt;Los paquetes de compilación se utilizan para predeterminar los siguientes archivos si aún no existen en el proyecto que se está creando/importando:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Dockerfile&lt;/code&gt; para convertir el código en una imagen de docker para ejecutarla en Kubernetes&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Jenkinsfile&lt;/code&gt; para definir de forma declarativa el pipeline de Jenkins para definir los pasos CI/CD de la aplicación&lt;/li&gt;
&lt;li&gt;helm chart en la carpeta &lt;code&gt;charts&lt;/code&gt; para generar los recursos de Kubernetes para ejecutar la apliación&lt;/li&gt;
&lt;li&gt;un &lt;em&gt;chart de vista previa&lt;/em&gt; en la carpeta &lt;code&gt;charts/preview&lt;/code&gt; para definir las dependencias para el despliegue hacia el &lt;a href=&#34;https://jenkins-x.io/es/about/concepts/features/#entornos-de-vista-previa&#34;&gt;entorno de vista previa&lt;/a&gt; en una solicitud de extracción.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Los paquetes de compilación predeterminados están en &lt;a href=&#34;https://github.com/jenkins-x-buildpacks/jenkins-x-kubernetes&#34;&gt;https://github.com/jenkins-x-buildpacks/jenkins-x-kubernetes&lt;/a&gt; con una carpeta para cada lenguaje o herramienta de compilación.&lt;/p&gt;
&lt;p&gt;La línea de comando &lt;code&gt;jx&lt;/code&gt; clona los paquetes de compilación en la carpeta &lt;code&gt;.~/.jx/draft/packs/&lt;/code&gt; y los actualiza a través del &lt;code&gt;git pull&lt;/code&gt; cada vez que intenta crear o importar un proyecto.&lt;/p&gt;
&lt;h2 id=&#34;modelo-de-extensión-pipeline&#34;&gt;Modelo de extensión Pipeline&lt;/h2&gt;
&lt;p&gt;Como parte de la transición de &lt;a href=&#34;https://jenkins-x.io/docs/resources/guides/managing-jx/common-tasks/cloud-native-jenkins/&#34;&gt;Jenkins hacia ser nativa de la nube&lt;/a&gt;, hemos reestructurado nuestros &lt;a href=&#34;https://github.com/jenkins-x-buildpacks/&#34;&gt;paquetes de compilación&lt;/a&gt; para que sean más modulares y más fáciles de componer y reutilizar en las cargas de trabajo.&lt;/p&gt;
&lt;p&gt;Por ejemplo, el paquete de compilación &lt;a href=&#34;https://github.com/jenkins-x-buildpacks/jenkins-x-kubernetes&#34;&gt;jenkins-x-kubernetes&lt;/a&gt; hereda del paquete de compilación &lt;a href=&#34;https://github.com/jenkins-x-buildpacks/jenkins-x-classic&#34;&gt;jenkins-x-classic&lt;/a&gt;, reutilizando el CI y los pipelines de liberación, pero luego agregando las cargas de trabajo específicas de Kubernetes (por ejemplo, construyendo imágenes de docker, creando charts de helm, &lt;a href=&#34;https://jenkins-x.io/es/about/concepts/features/#entornos-de-vista-previa&#34;&gt;vista previa de entornos&lt;/a&gt; y &lt;a href=&#34;https://jenkins-x.io/es/about/concepts/features/#promoci%C3%B3n&#34;&gt;promoción a través de GitOps&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Para hacer esto, hemos introducido un nuevo formato de archivo YAML simple para definir pipelines.&lt;/p&gt;
&lt;h2 id=&#34;pipelines&#34;&gt;Pipelines&lt;/h2&gt;
&lt;p&gt;Cada fichero Pipeline YAML tiene un número de pipelines separados lógicamente:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;release&lt;/code&gt; para procesar las mezclas a la rama &lt;code&gt;master&lt;/code&gt; que comúnmente crea una nueva versión y liberación, luego desencadena una promoción&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pullRequest&lt;/code&gt; para el procesamiento de las solicitudes de extracción (Pull Requests)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;feature&lt;/code&gt; para el procesamiento de las mezclas de las ramas de funcionalidades. Sin embargo, tenga en cuenta que el &lt;a href=&#34;https://jenkins-x.io/about/accelerate/&#34;&gt;libro accelerate&lt;/a&gt; no recomienda las ramas de funcionalidades a largo plazo. En su lugar, considere utilizar el desarrollo basado en troncales, que es una práctica de equipos de alto rendimiento.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ciclos-de-vida&#34;&gt;Ciclos de Vida&lt;/h2&gt;
&lt;p&gt;Luego, cada pipeline tiene una serie de fases distintas del ciclo de vida, algo así como Maven tiene &lt;code&gt;clean&lt;/code&gt;,&lt;code&gt; compile&lt;/code&gt;, &lt;code&gt;compile-test&lt;/code&gt;,&lt;code&gt; package&lt;/code&gt; etc.&lt;/p&gt;
&lt;p&gt;Estas fases de ciclos de vida en Jenkins X Pipeline YAML son:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;setup&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;preBuild&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;build&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;postBuild&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;promote&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;extensible&#34;&gt;Extensible&lt;/h2&gt;
&lt;p&gt;Un Pipeline YAML puede extender otro archivo YAML. Puede hacer referencia a un pipeline base YAML a través de:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;usando &lt;code&gt;file&lt;/code&gt; para hacer referencia a una ruta de archivo relativa en el mismo paquete de compilación &lt;a href=&#34;https://github.com/jenkins-x-buildpacks/jenkins-x-classic/blob/f7027df958eb385d50fec0c0368e606a6d5eb9df/packs/maven/pipeline.yaml#L1-L2&#34;&gt;como este ejemplo usando &lt;code&gt;file&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;usando &lt;code&gt;import&lt;/code&gt; para hacer referencia a un archivo YAML que se importa como este &lt;a href=&#34;https://github.com/jenkins-x-buildpacks/jenkins-x-kubernetes/blob/45819e05fa197d9069af682fbbcad0af8d8d605a/packs/maven/pipeline.yaml#L2-L3&#34;&gt;ejemplo usando import&lt;/a&gt; que luego se refiere a un &lt;a href=&#34;https://github.com/jenkins-x-buildpacks/jenkins-x-kubernetes/blob/45819e05fa197d9069af682fbbcad0af8d8d605a/packs/imports.yaml#L2-L4&#34;&gt;módulo importado nombrado a través de git&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;anteponer-pasos&#34;&gt;Anteponer pasos&lt;/h2&gt;
&lt;p&gt;Al igual que las clases en lenguajes como Java, puede anteponer los pasos en un Pipeline YAML desde un Pipeline YAML base. Esto le permite reutilizar los pasos en el ciclo de vida de un pipeline base y luego agregar sus propios pasos adicionales.&lt;/p&gt;
&lt;p&gt;Por defecto, todos los pasos que defina se agregan después de los pasos YAML del pipeline base, &lt;a href=&#34;https://github.com/jenkins-x/jx/blob/0520fe3d9740cbcb1cc9754e173fe7726219f58e/pkg/jx/cmd/test_data/step_buildpack_apply/inheritence/pipeline.yaml#L7&#34;&gt;como en este ejemplo&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Puede agregar pasos antes de los pasos del pipeline base utilizando la propiedad &lt;code&gt;preSteps:&lt;/code&gt; c&lt;a href=&#34;https://github.com/jenkins-x/jx/blob/0520fe3d9740cbcb1cc9754e173fe7726219f58e/pkg/jx/cmd/test_data/step_buildpack_apply/inheritence2/pipeline.yaml#L6&#34;&gt;omo este ejemplo&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Si desea reemplazar por completo todos los pasos de un pipeline base para un ciclo de vida particular, puede usar &lt;code&gt;replace: true&lt;/code&gt; como &lt;a href=&#34;https://github.com/jenkins-x/jx/blob/0520fe3d9740cbcb1cc9754e173fe7726219f58e/pkg/jx/cmd/test_data/step_buildpack_apply/inheritence2/pipeline.yaml#L11-L14&#34;&gt;en este ejemplo&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;pipeline-de-ejemplo&#34;&gt;Pipeline de ejemplo&lt;/h2&gt;
&lt;p&gt;Por ejemplo, para las bibliotecas maven, &lt;a href=&#34;https://github.com/jenkins-x-buildpacks/jenkins-x-classic/blob/f7027df958eb385d50fec0c0368e606a6d5eb9df/packs/maven/pipeline.yaml&#34;&gt;usamos este archivo pipeline.yaml&lt;/a&gt; que:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/jenkins-x-buildpacks/jenkins-x-classic/blob/f7027df958eb385d50fec0c0368e606a6d5eb9df/packs/maven/pipeline.yaml#L1-L2&#34;&gt;extiende&lt;/a&gt; el &lt;a href=&#34;https://github.com/jenkins-x-buildpacks/jenkins-x-classic/blob/f7027df958eb385d50fec0c0368e606a6d5eb9df/packs/pipeline.yaml&#34;&gt;pipeline común&lt;/a&gt; que configura git y define pasos comunes de compilación posterior&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/jenkins-x-buildpacks/jenkins-x-classic/blob/f7027df958eb385d50fec0c0368e606a6d5eb9df/packs/maven/pipeline.yaml#L3-L5&#34;&gt;configura el agente&lt;/a&gt; en términos de &lt;a href=&#34;https://jenkins-x.io/docs/resources/guides/managing-jx/common-tasks/pod-templates/&#34;&gt;plantilla de pod&lt;/a&gt; y nombre del contenedor&lt;/li&gt;
&lt;li&gt;define los pasos para los &lt;a href=&#34;https://github.com/jenkins-x-buildpacks/jenkins-x-classic/blob/f7027df958eb385d50fec0c0368e606a6d5eb9df/packs/maven/pipeline.yaml#L7-L11&#34;&gt;build steps&lt;/a&gt; del pipeline del &lt;code&gt;pull request&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;define el &lt;a href=&#34;https://github.com/jenkins-x-buildpacks/jenkins-x-classic/blob/f7027df958eb385d50fec0c0368e606a6d5eb9df/packs/maven/pipeline.yaml#L13-L18&#34;&gt;grupo de pasos de versión&lt;/a&gt; del pipeline de liberación y los &lt;a href=&#34;https://github.com/jenkins-x-buildpacks/jenkins-x-classic/blob/f7027df958eb385d50fec0c0368e606a6d5eb9df/packs/maven/pipeline.yaml#L19-L21&#34;&gt;pasos de compilación&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Luego, el &lt;a href=&#34;https://github.com/jenkins-x-buildpacks/jenkins-x-kubernetes/blob/45819e05fa197d9069af682fbbcad0af8d8d605a/packs/maven/pipeline.yaml&#34;&gt;pipeline de maven kubernetes.yaml&lt;/a&gt; se &lt;a href=&#34;https://github.com/jenkins-x-buildpacks/jenkins-x-kubernetes/blob/45819e05fa197d9069af682fbbcad0af8d8d605a/packs/maven/pipeline.yaml#L2-L3&#34;&gt;extiende&lt;/a&gt; desde el pipeline clásico para agregar los pasos kubernetes.&lt;/p&gt;
&lt;h1 id=&#34;crear-nuevos-paquetes-de-compilación&#34;&gt;Crear nuevos paquetes de compilación&lt;/h1&gt;
&lt;p&gt;Nos encantan las &lt;a href=&#34;https://jenkins-x.io/community/&#34;&gt;contribuciones&lt;/a&gt;, así que considere agregar nuevos paquetes de compilación y &lt;a href=&#34;https://jenkins-x.io/docs/resources/guides/managing-jx/common-tasks/pod-templates/&#34;&gt;plantillas de pod&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Aquí hay instrucciones sobre cómo crear un nuevo paquete de compilación. Por favor, si algo no está claro, &lt;a href=&#34;https://jenkins-x.io/community/&#34;&gt;únase a la comunidad y solo pregunte&lt;/a&gt;, aquí estamos encantados de ayudar.&lt;/p&gt;
&lt;p&gt;El mejor lugar para comenzar es una aplicación de &lt;em&gt;inicio rápido&lt;/em&gt;. Un proyecto de muestra que puede usar como prueba. Así que cree/encuentre un proyecto de ejemplo adecuado y luego &lt;a href=&#34;https://jenkins-x.io/docs/resources/guides/using-jx/creating/import/&#34;&gt;impórtelo&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Luego, agregue manualmente un &lt;code&gt;Dockerfile&lt;/code&gt; y un &lt;code&gt;Jenkinsfile&lt;/code&gt; si aún no ha agregado uno para usted. Puede comenzar con los archivos de las &lt;a href=&#34;https://github.com/jenkins-x-buildpacks/jenkins-x-kubernetes/tree/master/packs&#34;&gt;carpetas del paquete de compilación actual&lt;/a&gt;, utilizando el lenguaje/framework más similar al suyo.&lt;/p&gt;
&lt;p&gt;Si su paquete de compilación está utilizando herramientas de compilación que aún no están disponibles en una de las &lt;a href=&#34;https://jenkins-x.io/es/docs/reference/components/pod-templates/&#34;&gt;plantillas de pod&lt;/a&gt; existentes, entonces deberá &lt;a href=&#34;https://jenkins-x.io/es/docs/reference/components/pod-templates/#enviar-nuevas-plantillas-de-pod&#34;&gt;enviar una nueva plantilla de pod&lt;/a&gt;, probablemente también utilizando una nueva imagen del contenedor de compilación.&lt;/p&gt;
&lt;p&gt;Una vez que tenga una plantilla de pod para usar, por ejemplo, &lt;code&gt;jenkins-foo&lt;/code&gt;, consulte en su &lt;code&gt;Jenkinsfile&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-groovy&#34; data-lang=&#34;groovy&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// my declarative Jenkinsfile
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;pipeline &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    agent &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      label &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;jenkins-foo&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    environment &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    stages &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      stage&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;CI Build and push snapshot&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        steps &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          container&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;foo&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            sh &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;foo deploy&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Una vez que su &lt;code&gt;Jenkinsfile&lt;/code&gt; sea capaz de hacer CI/CD para su lenguage/tiempo de ejecución en su proyecto de muestra, entonces deberíamos poder tomar el &lt;code&gt;Dockerfile&lt;/code&gt;, el &lt;code&gt;Jenkinsfile&lt;/code&gt; y la carpeta de charts y copiarlos en una carpeta en su bifurcación del &lt;a href=&#34;https://github.com/jenkins-x-buildpacks/jenkins-x-kubernetes&#34;&gt;jenkins-x/draft-packs repository&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Puede probarlo localmente agregando estos archivos a su clon local del repositorio de paquetes de compilación en &lt;code&gt;~/.jx/draft/packs/github.com/jenkins-x/draft-packs/packs&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;p.ej.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;export PACK&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;foo&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mkdir ~/.jx/draft/packs/github.com/jenkins-x/draft-packs/packs/$PACK
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cp Dockerfile Jenkinsfile  ~/.jx/draft/packs/github.com/jenkins-x/draft-packs/packs/$PACK
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# the charts will be in some folder charts/somefoo&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cp -r charts/somefoo ~/.jx/draft/packs/github.com/jenkins-x/draft-packs/packs/$PACK/charts
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Una vez que su paquete de compilación esté en una carpeta en &lt;code&gt;~/.jx/draft/packs/github.com/jenkins-x/draft-packs/packs/&lt;/code&gt;, entonces debería ser utilizable por el comando &lt;a href=&#34;https://jenkins-x.io/commands/jx_import/&#34;&gt;jx import&lt;/a&gt; que utiliza la detección del lenguaje de programación para encontrar el paquete de compilación más adecuado para usar al importar un proyecto. Si su paquete de compilación requiere una lógica personalizada para detectarlo, avísenos y podemos ayudarlo agregando un parche en el comando &lt;a href=&#34;https://jenkins-x.io/commands/jx_import/&#34;&gt;jx import&lt;/a&gt; para que funcione mejor para su paquete de compilación. Por ejemplo, tenemos una lógica personalizada para &lt;a href=&#34;https://github.com/jenkins-x/jx/blob/712d9edf5e55aafaadfb3e0ac57692bb44634b1c/pkg/jx/cmd/common_buildpacks.go#L82:L108&#34;&gt;manejar mejor a Maven y Gradle&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Si necesitas más ayuda &lt;a href=&#34;https://jenkins-x.io/community/&#34;&gt;únete a la comunidad&lt;/a&gt;.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Jenkins Nativo de la Nube</title>
      <link>https://jenkins-x.io/es/docs/reference/components/cloud-native-jenkins/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jenkins-x.io/es/docs/reference/components/cloud-native-jenkins/</guid>
      <description>
        
        
        &lt;p&gt;Jenkins X ayuda a admitir &lt;em&gt;Jenkins nativo en la nube&lt;/em&gt; a través de:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;orquestando tanto &lt;a href=&#34;https://jenkins-x.io/news/serverless-jenkins/&#34;&gt;Jenkins sin servidor&lt;/a&gt; con &lt;a href=&#34;https://jenkins-x.io/architecture/prow/&#34;&gt;prow&lt;/a&gt; como Jenkins Estático con maestros por equipo. Esto permite que los equipos se muevan hacia un sistema sin servidor mientras que también traen maestros estáticos.&lt;/li&gt;
&lt;li&gt;cada equipo puede instalar su propio Jenkins X en su propio namespace (a través de &lt;code&gt;jx install --namespace myteam&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;soporte para diferentes cargas de trabajo por equipo (ver &lt;a href=&#34;https://jenkins-x.io/commands/jx_edit_buildpack/&#34;&gt;jx edit buildpack&lt;/a&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;diferentes-cargas-de-trabajo&#34;&gt;Diferentes cargas de trabajo&lt;/h2&gt;
&lt;p&gt;Algunos equipos desarrollan aplicaciones nativas en la nube en Kubernetes y, por lo tanto, deberían usar la opción &lt;code&gt;kubernetes workloads&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Para los equipos que no implementan aplicaciones en Kubernetes, como la entrega de bibliotecas o binarios, hay una nueva opción de &lt;code&gt;carga de trabajo de biblioteca&lt;/code&gt; que tiene CI y versiones automatizadas pero no CD.&lt;/p&gt;
&lt;p&gt;Cuando &lt;a href=&#34;https://jenkins-x.io/es/docs/getting-started/setup/create-cluster/&#34;&gt;crea un clúster&lt;/a&gt; o &lt;a href=&#34;https://jenkins-x.io/docs/resources/guides/managing-jx/common-tasks/install-on-cluster/&#34;&gt;instala Jenkins X&lt;/a&gt;, se le solicita que elija entre los paquetes de construcción disponibles.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;? Pick workload build pack:   &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;Use arrows to move, type to filter&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;gt; Kubernetes Workloads: Automated CI+CD with GitOps Promotion
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Library Workloads: CI+Release but no CD
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Puede cambiar esta configuración en cualquier momento a través de &lt;a href=&#34;https://jenkins-x.io/commands/jx_edit_buildpack/&#34;&gt;jx edit buildpack&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Por defecto, simplemente presione enter para apegarse a la opción de cargas de trabajo de Kubernetes. Sin embargo, si tiene un número significativo de bibliotecas que desea administrar, puede configurar un equipo separado para esto e importar sus diversos proyectos de biblioteca allí.&lt;/p&gt;
&lt;h2 id=&#34;cargas-de-trabajo-actuales&#34;&gt;Cargas de trabajo actuales&lt;/h2&gt;
&lt;p&gt;Almacenamos nuestros paquetes de construcción en la organización &lt;a href=&#34;https://github.com/jenkins-x-buildpacks/&#34;&gt;jenkins-x-buildpacks&lt;/a&gt; en GitHub. Actualmente apoyamos:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;el paquete de construcción &lt;a href=&#34;https://github.com/jenkins-x-buildpacks/jenkins-x-classic&#34;&gt;jenkins-x-classic&lt;/a&gt; es compatible con las versiones CI+Release, pero no incluye el CD. p.ej. hacer CI y liberar sus bibliotecas Java o módulos de Nodo pero no desplegarlas en Kubernetes.&lt;/li&gt;
&lt;li&gt;el paquete de construcción &lt;a href=&#34;https://github.com/jenkins-x-buildpacks/jenkins-x-kubernetes&#34;&gt;jenkins-x-kubernetes&lt;/a&gt; admite el CI+CD automatizado con la promoción GitOps y entornos de vista previa para &lt;code&gt;cargas de trabajo de Kubernetes&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Sin embargo, debería poder extender cualquiera de estos paquetes de construcción para agregar plataformas y capacidades alternativas.&lt;/p&gt;
&lt;h2 id=&#34;escribiendo-su-propio-paquete-de-construcción&#34;&gt;Escribiendo su propio paquete de construcción&lt;/h2&gt;
&lt;p&gt;Queremos que &lt;a href=&#34;https://jenkins-x.io/docs/contributing/addons/&#34;&gt;extienda Jenkins X&lt;/a&gt;, así que consulte la documentación sobre [cómo crear sus propios paquetes de construcción]/docs/resources/guides/managing-jx/common-tasks/build-packs/#creating-new-build-packs).&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Prow</title>
      <link>https://jenkins-x.io/es/docs/reference/components/prow/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jenkins-x.io/es/docs/reference/components/prow/</guid>
      <description>
        
        
        &lt;p&gt;Prow es un sistema CI/CD basado en Kubernetes. Los trabajos pueden ser activados por varios tipos de eventos e informar su estado a muchos servicios diferentes. Además de la ejecución del trabajo, Prow proporciona automatización de GitHub en forma de cumplimiento de políticas, operaciones de chat a través de comandos de estilo /foo y mezclas automáticamente las solicitudes de extracción (Pull Request, PR).&lt;/p&gt;
&lt;p&gt;Prow tiene una arquitectura de microservicio implementada como una colección de contenedor que se ejecutan como despliegues de Kubernetes.&lt;/p&gt;
&lt;h2 id=&#34;hook&#34;&gt;hook&lt;/h2&gt;
&lt;p&gt;Hay un &lt;a href=&#34;https://github.com/kubernetes/test-infra/tree/master/prow/cmd/hook&#34;&gt;binario llamado hook&lt;/a&gt; que recibe todos los enganches web de GitHub. Es un servidor sin estado que escucha los webhooks de GitHub y los envía a los plugins apropiados. Los plugins de Hook se usan para activar trabajos, implementar comandos en &lt;code&gt;slash&lt;/code&gt;, publicar en Slack y más. El enlace binario expone un punto final /hook para recibir las solicitudes de enlace web del servidor Git (básicamente todos los enlaces web van a /hook). Hay una regla de ingreso que expone ese punto final al exterior del clúster.&lt;/p&gt;
&lt;h2 id=&#34;prow-plugins&#34;&gt;Prow Plugins&lt;/h2&gt;
&lt;p&gt;El &lt;a href=&#34;https://github.com/kubernetes/test-infra/tree/master/prow/cmd/hook&#34;&gt;binario hook&lt;/a&gt; usa diferentes plugins que se pueden habilitar/deshabilitar de forma independiente, para hacer cosas diferentes. Básicamente son controladores de eventos para los diferentes eventos de GitHub recibidos a través de enlaces web. Estos plugins se configuran utilizando una configuración yaml que se pasa desde un ConfigMap de Kubernetes para establecer el enlace, y se puede habilitar por repositorio u organización.
Todos los plugins tienen la misma interfaz. El proceso de enlace pasa dos objetos a cada plugin es: un cliente del plugin que les permite hablar con k8s, git, GitHub, los archivos de propietarios en git repo, slack, etc., y el evento deserializado de GitHub (como IssueCommentEvent).&lt;/p&gt;
&lt;h3 id=&#34;lgtm-plugin&#34;&gt;lgtm plugin&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/test-infra/tree/master/prow/plugins/lgtm&#34;&gt;El plugin LGTM&lt;/a&gt; es un buen ejemplo para comenzar a usar plugins. Es un complemento que agrega la etiqueta LGTM cuando alguien comenta /lgtm en una solicitud de extracción.&lt;/p&gt;
&lt;h3 id=&#34;updateconfig-plugin&#34;&gt;UpdateConfig plugin&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/test-infra/tree/master/prow/plugins/updateconfig&#34;&gt;Un plugin que actualiza automáticamente un ConfigMap&lt;/a&gt; cada vez que se mezcla un PR en un repositorio. De esta forma, puede mantener actualizados automáticamente sus ConfigMaps, siguiendo un flujo de GitOps.
Puede asignar archivos específicos a ConfigMaps, o incluso usar expresiones regulares.
Normalmente se usa para actualizar el ConfigMap que contiene la configuración de Prow, por lo que cada vez que un PR se mezcla con cambios en los archivos que contienen la configuración de Prow, ConfigMap se actualizará automáticamente.&lt;/p&gt;
&lt;h3 id=&#34;trigger-plugin&#34;&gt;Trigger plugin&lt;/h3&gt;
&lt;p&gt;Probablemente el plugin más importante. Es un plugin que reacciona a los comentarios en los PR, por lo que podemos desencadenar construcciones (escribiendo &amp;ldquo;prueba&amp;rdquo; como un comentario o cualquier otro desencadenante). Determina qué trabajos ejecutar en función de la configuración del trabajo. Cuando encuentra un trabajo que necesita ser activado, crea un &lt;a href=&#34;https://github.com/kubernetes/test-infra/blob/master/prow/apis/prowjobs/v1/types.go#L85&#34;&gt;ProwJob CRD&lt;/a&gt;, utilizando la configuración que se encuentra en el enganche del ConfigMap (de esa manera puede crear un objeto &lt;a href=&#34;https://github.com/kubernetes/test-infra/blob/master/prow/apis/prowjobs/v1/types.go#L85&#34;&gt;ProwJob&lt;/a&gt; diferente dependiendo de la organización o repositorio, como usar un agente de construcción diferente (Jenkins vs Knative vs pods), el tipo de trabajo, etc. Este CRD contiene algunos campos interesantes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;agent: para seleccionar qué controlador k8s se encargará de este trabajo&lt;/li&gt;
&lt;li&gt;refs: Repositorio y revisión de GitHub para usar para el código fuente&lt;/li&gt;
&lt;li&gt;type: ya sea envío previo o posterior al envío (ejecute el trabajo antes de mezclar o publicar)&lt;/li&gt;
&lt;li&gt;pod_spec: especificación para crear un objeto Pod, si usamos &lt;a href=&#34;https://github.com/kubernetes/test-infra/tree/master/prow/plank&#34;&gt;plank&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;build_spec: especificación para crear un &lt;a href=&#34;https://github.com/knative/docs/blob/master/build/builds.md&#34;&gt;objeto Knative Build&lt;/a&gt;, si se está utilizando &lt;a href=&#34;https://github.com/kubernetes/test-infra/blob/master/prow/cmd/build/controller.go&#34;&gt;prow-build&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;El ciclo de vida de un &lt;a href=&#34;https://github.com/kubernetes/test-infra/blob/master/prow/apis/prowjobs/v1/types.go#L85&#34;&gt;ProwJob&lt;/a&gt; es gestionado por el controlador de ProwJob que está ejecutándose en el clúster. Los posibles estados del ProwJob son:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;triggered: el trabajo ha sido creado pero aún no está programado.&lt;/li&gt;
&lt;li&gt;pending: el trabajo ha sido programado pero no ejecutado.&lt;/li&gt;
&lt;li&gt;Success/failure: El trabajo se ha completado.&lt;/li&gt;
&lt;li&gt;aborted: significa que Prow detuvo el trabajo antes de tiempo (nueva confirmación empujada, tal vez).&lt;/li&gt;
&lt;li&gt;error: significa que el trabajo no ha sido programado (tal vez por una mala configuración).&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;job-type&#34;&gt;Job Type&lt;/h4&gt;
&lt;p&gt;En la configuración de Prow, puede configurar trabajos de Presubmits y Postsubmits por repositorio que se activan con el plugin de activación. Los envíos previos (&lt;code&gt;Presubmits&lt;/code&gt;) se ejecutan cuando el código PR cambia (abriendo un nuevo PR o enviando código a la rama del PR), para que pueda probar los cambios en su nuevo código. Las publicaciones posteriores (&lt;code&gt;Postsubmits&lt;/code&gt;) se ejecutan cada vez que aparece una nueva confirmación en una rama de origen (evento push de GitHub).&lt;/p&gt;
&lt;p&gt;El caso de uso para envíos posteriores es donde puede haber menos de 100 mezclas por día en un repositorio de gran volumen, pero podría haber diez o cien veces más que muchos trabajos de envío previo ejecutados. Los envíos de correos se pueden usar cuando algo es muy costoso de probar y no necesariamente bloquea la mezcla, pero sí desea señal. Del mismo modo, la forma en que mezcla el sistema es que su verificación previa al envío se ejecutará con su código mezclado en la rama a la que se dirige, por lo que técnicamente el compromiso de mezcla que termina en la rama &lt;code&gt;master&lt;/code&gt; ya se ha probado de manera efectiva y, a menudo, esto significa que puede desea un trabajo de envío previo pero no duplicarlo también, ya que no le da más señal.&lt;/p&gt;
&lt;h3 id=&#34;prowjob-controllers&#34;&gt;ProwJob controllers&lt;/h3&gt;
&lt;p&gt;Más tarde, podemos usar diferentes operadores de Kubernetes que reaccionan a los objetos ProwJob para ejecutar nuestras construcciones, en función del campo del agente (cada operador busca ProwJobs con un valor de agente específico):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kubernetes/test-infra/blob/master/prow/plank/controller.go&#34;&gt;Plank&lt;/a&gt; es uno que utiliza pods de Kubernetes. Usa el campo &lt;code&gt;pod_spec&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kubernetes/test-infra/blob/master/prow/cmd/build/controller.go&#34;&gt;prow-build&lt;/a&gt; es un operador de construcción que utiliza Knative Build CRD. Utiliza el campo &lt;code&gt;build_spec&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;There is a &lt;a href=&#34;https://github.com/kubernetes/test-infra/blob/master/prow/jenkins/controller.go&#34;&gt;jenkins-operator&lt;/a&gt; que se ejecuta en Jenkins. Esto no se recomienda actualmente.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Estos controladores administran &lt;a href=&#34;https://github.com/kubernetes/test-infra/blob/master/prow/life_of_a_prow_job.md&#34;&gt;el ciclo de vida de un ProwJob&lt;/a&gt;.&lt;/p&gt;
&lt;h4 id=&#34;plankhttpsgithubcomkubernetestest-infratreemasterprowplank&#34;&gt;&lt;a href=&#34;https://github.com/kubernetes/test-infra/tree/master/prow/plank&#34;&gt;plank&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Plank es un operador de Kubernetes que reacciona a los recursos personalizados de ProwJob. Crea un Pod para ejecutar la compilación asociada con el objeto ProwJob. El objeto ProwJob en sí contiene un PodSpec.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Si ProwJob no tiene un Pod, crea un pod para ejecutar la construcción. Use init-container para hacer la obtención de VCS.&lt;/li&gt;
&lt;li&gt;Si ProwJob tiene un Pod con estado completado, marque ProwJob como completado.&lt;/li&gt;
&lt;li&gt;Si se completa ProwJob, no haga nada.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Nosotros utilizamos construcciones Knative en Jenkins X, que utilizan el &lt;a href=&#34;https://github.com/kubernetes/test-infra/blob/master/prow/cmd/build/controller.go&#34;&gt;controlador prow-build&lt;/a&gt;, por lo que no tiene que preocuparse por plank.&lt;/p&gt;
&lt;h4 id=&#34;prow-buildhttpsgithubcomkubernetestest-infrablobmasterprowcmdbuildcontrollergo&#34;&gt;&lt;a href=&#34;https://github.com/kubernetes/test-infra/blob/master/prow/cmd/build/controller.go&#34;&gt;prow-build&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Operador de Kubernetes que observa los objetos de ProwJob y reacciona a aquellos cuyo campo de agente es el agente de construcción Knative. Creará &lt;a href=&#34;https://github.com/knative/docs/blob/master/build/builds.md&#34;&gt;un objeto Knative Build&lt;/a&gt; basado en el campo &lt;code&gt;build_spec&lt;/code&gt; del objeto ProwJob.
&lt;a href=&#34;https://github.com/knative/build/blob/master/cmd/controller/main.go&#34;&gt;El controlador de construcción de Knative&lt;/a&gt; reacciona y crea un Pod para ejecutar la construcción. Todos los ProwJob, Build y Pod tienen el mismo nombre (un UUID).&lt;/p&gt;
&lt;p&gt;El objeto Build contiene campos interesantes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;serviceAccountName: &lt;a href=&#34;https://github.com/knative/docs/blob/master/build/auth.md&#34;&gt;ServiceAccount contiene los Secrets necesarios para acceder al servidor Git o al registro Docker&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;source: Repositorio y revisión de Git para usar para el código fuente.&lt;/li&gt;
&lt;li&gt;steps: Especifica una o más imágenes de contenedores que desea ejecutar en su construcción. Cada imagen de contenedor se ejecuta hasta su finalización o hasta que se detecta la primera falla.&lt;/li&gt;
&lt;li&gt;template: contiene el nombre de un Knative BuildTemplate registrado, junto con las variables de entorno para pasar al objeto Build. La plantilla debe ser un objeto BuildTemplate que exista en el clúster. &lt;strong&gt;Si se define el campo de plantilla, el campo de pasos se ignorará&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;steps&#34;&gt;Steps&lt;/h5&gt;
&lt;p&gt;Los pasos en una compilación son las diferentes acciones que se ejecutarán como parte de esa construcción. Cada paso en una construcción que debe especificar una imagen del Builder, o el tipo de imagen del contenedor que se adhiere al &lt;a href=&#34;https://github.com/knative/docs/blob/master/build/builder-contract.md&#34;&gt;Contrato del constructor Knative&lt;/a&gt; . Estos pasos/imágenes del constructor&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Se ejecutan y evalúan en orden, comenzando desde la parte superior del archivo de configuración.&lt;/li&gt;
&lt;li&gt;Cada uno se ejecuta hasta su finalización o hasta que se detecta la primera falla.&lt;/li&gt;
&lt;li&gt;Tener dos volúmenes que se comparten entre todos los pasos. Uno se montará en /workspace, que contiene el código especificado en el campo fuente Build. Otro es /builder/home que está montado en $HOME, y se usa principalmente para guardar archivos de credenciales que se usarán en diferentes pasos.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Una imagen del builder es una imagen especial que podemos ejecutar como un paso de Build CRD, y que normalmente es un contenedor especialmente diseñado cuyo punto de entrada es una herramienta que realiza algunas acciones y sale con un estado cero en caso de éxito. Estos puntos de entrada suelen ser herramientas de línea de comandos, por ejemplo, git, docker, mvn, etc.&lt;/p&gt;
&lt;h5 id=&#34;buildtemplate&#34;&gt;BuildTemplate&lt;/h5&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/knative/docs/blob/master/build/build-templates.md&#34;&gt;Un BuildTemplate&lt;/a&gt; encapsula un proceso de compilación compartida con algunas capacidades de parametrización limitadas.&lt;/p&gt;
&lt;p&gt;Una plantilla contiene pasos para ejecutar en la compilación. En lugar de especificar los mismos pasos en diferentes compilaciones, podemos reutilizar esos pasos creando una BuildTemplate que contenga estos pasos. Utilizamos BuildTemplates para compartir pasos entre diferentes Builds. Hay &lt;a href=&#34;https://github.com/knative/build-templates/&#34;&gt;BuildTemplates de la comunidad&lt;/a&gt; que puede usar, o puede definir sus propias plantillas.&lt;/p&gt;
&lt;h6 id=&#34;jenkins-x-build-templates&#34;&gt;Jenkins X Build Templates&lt;/h6&gt;
&lt;p&gt;Jenkins X utiliza BuildTemplates personalizadas para ejecutar las compilaciones de las aplicaciones. En &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-serverless&#34;&gt;este repositorio&lt;/a&gt; puede encontrar las diferentes BuildTemplates disponibles, según el lenguaje de la aplicación. Estas BuildTemplates usan una imagen de constructor de Step diferente según el lenguaje, ya que tienen que construir la aplicación usando diferentes herramientas como maven, go o Gradle. Por lo tanto, cada imagen de Builder tiene diferentes herramientas instaladas, aunque eventualmente todas las imágenes de Builder básicamente ejecutan &lt;a href=&#34;https://jenkins-x.io/news/serverless-jenkins/&#34;&gt;Jenkins sin servidor&lt;/a&gt; (también conocido como &lt;a href=&#34;https://github.com/jenkinsci/jenkinsfile-runner&#34;&gt;Jenkinsfile-Runner&lt;/a&gt;). Eso permite que nuestras compilaciones definan los pasos en un Jenkinsfile. Todos estos pasos se ejecutan dentro del mismo &lt;a href=&#34;https://hub.docker.com/r/jenkins/jenkinsfile-runner/dockerfile/&#34;&gt;contenedor Jenkinsfile Runner&lt;/a&gt;, que no coincide con el modelo de pasos de Knative Build.&lt;/p&gt;
&lt;h5 id=&#34;el-trabajo-se-ejecuta-dentro-del-pod&#34;&gt;El trabajo se ejecuta dentro del Pod&lt;/h5&gt;
&lt;p&gt;El Pod que se creó para ejecutar la compilación real tiene un contenedor que no hace nada, pero tiene contenedores de inicio para realizar los pasos necesarios para ejecutar el trabajo:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/knative/build/tree/master/cmd/creds-init&#34;&gt;creds-init&lt;/a&gt;: Los Secrets de la cuenta de servicio se montan en /var/build-secrets/ para que este contenedor tenga acceso a ellos. Los agrega en sus respectivos archivos de credenciales en $HOME, que es otro volumen compartido entre todos los pasos. Típicamente credenciales para el servidor git y el registro de docker.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/knative/build/tree/master/cmd/git-init&#34;&gt;git-init&lt;/a&gt;: clona el repositorio SHA/revisión Git especificado en uno de los volúmenes compartidos /workspace&lt;/li&gt;
&lt;li&gt;Otro contenedor de inicio para cada paso definido en Build o BuildTemplate.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Recuerde que cada contenedor de inicio usa su propia imagen de contenedor. Además, tienen diferentes namespaces de Linux del sistema de archivos. Pero tienen algunos volúmenes compartidos como las carpetas $HOME y /workspace.&lt;/p&gt;
&lt;h2 id=&#34;sinker&#34;&gt;sinker&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/test-infra/tree/master/prow/cmd/sinker&#34;&gt;Recolector de basura&lt;/a&gt; para ProwJobs y Pods creados para ejecutar compilaciones. Elimina ProwJobs completos después de 2 días y pods completados después de 30 minutos.&lt;/p&gt;
&lt;h2 id=&#34;crier&#34;&gt;crier&lt;/h2&gt;
&lt;p&gt;Otro controlador de Kubernetes que mira CRD de ProwJobs. Contiene diferentes notificadores de los cambios de ProwJob a clientes externos, como la verificación del estado de GitHub o un mensaje a PubSub.&lt;/p&gt;
&lt;p&gt;Se utiliza para actualizar el estado de confirmación de GitHub cuando finaliza ProwJob.&lt;/p&gt;
&lt;h2 id=&#34;deck&#34;&gt;deck&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://prow.k8s.io/&#34;&gt;Presenta una UI de trabajos recientes&lt;/a&gt; e &lt;a href=&#34;https://prow.k8s.io/command-help&#34;&gt;información de ayuda de comandos/plugins&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;tide&#34;&gt;tide&lt;/h2&gt;
&lt;p&gt;Los RP que satisfacen un conjunto de criterios predefinidos se pueden configurar para que &lt;a href=&#34;https://github.com/kubernetes/test-infra/blob/master/prow/cmd/tide/README.md&#34;&gt;Tide&lt;/a&gt; los mezcle automáticamente. Volverá a probar automáticamente los RP que cumplan con los criterios (&amp;ldquo;marea alta&amp;rdquo;) y los mezclará automáticamente cuando tengan resultados de prueba aprobados (&amp;ldquo;marea baja&amp;rdquo;).&lt;/p&gt;
&lt;p&gt;Consultará a GitHub de vez en cuando tratando de mezclar las solicitudes de extracción. No reacciona a los eventos, no es un plugin.&lt;/p&gt;
&lt;h2 id=&#34;esfuerzos-en-curso&#34;&gt;Esfuerzos en curso&lt;/h2&gt;
&lt;p&gt;Uso de contenedores de inicio para los pasos &lt;a href=&#34;https://github.com/knative/build/pull/470&#34;&gt;puede cambiar en el futuro&lt;/a&gt;, debido a limitaciones en los contenedores de inicio.
Knative Build CRD está en desuso en favor de Pipeline CRD. Build CRD será reemplazado por el nuevo Task CRD, pero son muy similares.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Lighthouse</title>
      <link>https://jenkins-x.io/es/docs/reference/components/lighthouse/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jenkins-x.io/es/docs/reference/components/lighthouse/</guid>
      <description>
        
        
        &lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/test-infra/tree/master/prow&#34;&gt;Prow&lt;/a&gt; es una excelente manera de hacer &lt;a href=&#34;https://jenkins-x.io/es/docs/resources/faq/using/chatops/&#34;&gt;ChatOps&lt;/a&gt; con los &lt;a href=&#34;https://jenkins-x.io/es/about/concepts/jenkins-x-pipelines/&#34;&gt;Pipelines de Jenkins X&lt;/a&gt;, aunque desafortunadamente solo es compatible con GitHub.com y es bastante pesado y complejo. Para solucionar este problema, hemos creado &lt;a href=&#34;https://github.com/jenkins-x/lighthouse&#34;&gt;Lighthouse&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/jenkins-x/lighthouse&#34;&gt;Lighthouse&lt;/a&gt; es un gestor de webhooks ligero basado en &lt;a href=&#34;https://jenkins-x.io/es/docs/resources/faq/using/chatops/&#34;&gt;ChatOps&lt;/a&gt; que puede activar los &lt;a href=&#34;https://jenkins-x.io/es/about/concepts/jenkins-x-pipelines/&#34;&gt;Pipelines de Jenkins X&lt;/a&gt; en webhooks de múltiples proveedores de git como: GitHub, GitHub Enterprise, BitBucket Server, BitBucket Cloud, GitLab, Gogs y Gitea.&lt;/p&gt;
&lt;p&gt;Actualmente, Lighthouse se enfoca en usar &lt;a href=&#34;https://jenkins-x.io/about/concepts/jenkins-x-pipelines/&#34;&gt;Jenkins X Pipelines&lt;/a&gt; con Tekton, aunque a largo plazo podría reutilizarse con Tekton orquestando pipelines de Jenkins a través de la aplicación &lt;a href=&#34;https://jenkins-x.io/docs/resources/guides/managing-jx/common-tasks/custom-jenkins/&#34;&gt;Custom Jenkins Server&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;features&#34;&gt;Features&lt;/h2&gt;
&lt;p&gt;Actualmente, Lighthouse admite los &lt;a href=&#34;https://github.com/jenkins-x/lighthouse/tree/master/pkg/prow/plugins&#34;&gt;plugins comunes de prow&lt;/a&gt; y maneja los webhooks de inserción a las ramas y los webhooks de solicitud de extracción para luego activar los pipelines Jenkins X.&lt;/p&gt;
&lt;p&gt;Lighthouse utiliza la misma estructura de archivos &lt;code&gt;config.yaml&lt;/code&gt; and &lt;code&gt;plugins.yaml&lt;/code&gt; de Prow para que podamos migrar fácilmente desde &lt;code&gt;prow &amp;lt;-&amp;gt; lighthouse&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Esto también significa que podemos reutilizar la limpia generación de la configuración de Prow desde los CRD de &lt;code&gt;SourceRepository&lt;/code&gt;, &lt;code&gt;SourceRepositoryGroup&lt;/code&gt; y &lt;code&gt;Scheduler&lt;/code&gt; integrados en &lt;a href=&#34;https://jenkins-x.io/docs/reference/boot/&#34;&gt;jx boot&lt;/a&gt;. p.ej. Aquí está la &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-boot-config/blob/master/env/templates/default-scheduler.yaml&#34;&gt;configuración predeterminada del planificador&lt;/a&gt; que se utiliza para cualquier proyecto importado a su clúster Jenkins X; sin tener que tocar los archivos de configuración de Prow. Puede crear muchos planificadores y asociarlos a diferentes recursos de &lt;code&gt;SourceRepository&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;También podemos reutilizar la capacidad de Prow de definir muchos pipelines separados en un repositorio (para PR o versiones) a través de contextos separados. Luego, en una solicitud de extracción, podemos usar &lt;code&gt;/test something&lt;/code&gt; o &lt;code&gt;/test all&lt;/code&gt; para activar los pipelines y usar los comandos &lt;code&gt;/ok-to-test&lt;/code&gt; y &lt;code&gt;/approve&lt;/code&gt; o &lt;code&gt;/lgtm&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;using-lighthouse-with-boot&#34;&gt;Using Lighthouse with boot&lt;/h2&gt;
&lt;p&gt;Hemos integrado &lt;a href=&#34;https://github.com/jenkins-x/lighthouse&#34;&gt;lighthouse&lt;/a&gt; en &lt;a href=&#34;https://jenkins-x.io/docs/reference/boot/&#34;&gt;jx boot&lt;/a&gt;. Para cambiar a &lt;code&gt;lighthouse&lt;/code&gt; desde &lt;code&gt;prow&lt;/code&gt;, debe agregar algo como esto a su fichero &lt;code&gt;jx-requirements.yml&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;webhook&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;lighthouse&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Una vez modificado su fichero &lt;code&gt;jx-requirements.yml&lt;/code&gt; solo tiene que ejecutar el comando &lt;code&gt;jx boot&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Si está utilizando algo más que github.com como su proveedor de git, también necesitará un poco más de YAML para configurar el proveedor de git. Aquí hay unos ejemplos:&lt;/p&gt;
&lt;h2 id=&#34;github-enterprise&#34;&gt;GitHub Enterprise&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;cluster&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;provider&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;gke&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;zone&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;europe-west1-c&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;environmentGitOwner&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;myowner&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;gitKind&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;github&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;gitName&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;ghe&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;gitServer&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;https://my-github.com&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;webhook&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;lighthouse&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;bitbucket-server&#34;&gt;BitBucket Server&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;cluster&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;provider&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;gke&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;environmentGitOwner&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;myowner&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;gitKind&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;bitbucketserver&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;gitName&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;bs&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;gitServer&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;https://my-bitbucket-server.com&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;webhook&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;lighthouse&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;gitlab&#34;&gt;GitLab&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;cluster&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;provider&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;gke&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;environmentGitOwner&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;myowner&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;gitKind&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;gitlab&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;gitName&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;gitlab&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;gitServer&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;https://my-gitlab-server.com&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;webhook&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;lighthouse&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;comparaciones-con-prow&#34;&gt;Comparaciones con Prow&lt;/h2&gt;
&lt;p&gt;Lighthouse es muy parecido a Prow y actualmente reutiliza el código fuente del complemento Prow y un &lt;a href=&#34;https://github.com/jenkins-x/lighthouse/tree/master/pkg/prow/plugins&#34;&gt;montón de plugins de prow&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Sin embargo, tiene algunas diferencias:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;en lugar de ser un faro específico de GitHub, utiliza &lt;a href=&#34;https://github.com/jenkins-x/go-scm&#34;&gt;jenkins-x/go-scm&lt;/a&gt; para que pueda ser compatible con cualquier proveedor de git&lt;/li&gt;
&lt;li&gt;lighthouse es principalmente como el servicio &lt;code&gt;hook&lt;/code&gt; de Prow; un controlador de webhook de escala automática: para mantener el tamaño reducido. Esto también significa que si algo sale mal manejando webhooks, solo tiene un pod para investigar.&lt;/li&gt;
&lt;li&gt;lighthouse también es muy ligero. En Jenkins X tenemos alrededor de 10 pods relacionados con Prow; con lighthouse tenemos solo 1 junto con el controlador Tekton en sí. Ese módulo lighthouse también podría escalarse fácilmente de 0 a muchos, ya que se inicia muy rápidamente.&lt;/li&gt;
&lt;li&gt;lighthouse se centra exclusivamente en las tuberías de Tekton, por lo que no requiere un CRD &lt;code&gt;ProwJob&lt;/code&gt;; en cambio, un webhook de inserción a una rama de solicitud de liberación o extracción puede desencadenar cero a muchos CRD de &lt;code&gt;PipelineRun&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;portar-comandos-de-prow&#34;&gt;Portar comandos de Prow&lt;/h2&gt;
&lt;p&gt;Si hay algún comando de Prow que desee que aún no hayamos transferido, es relativamente fácil portar plugins de Prow.&lt;/p&gt;
&lt;p&gt;Hemos reutilizado el código del plugin de Prow y el código de configuración; Por lo tanto, se trata principalmente de cambiar las importaciones de &lt;code&gt;k8s.io/test-infra/prow&lt;/code&gt; a &lt;code&gt;github.com/jenkins-x/lighthouse/pkg/prow&lt;/code&gt;, y luego modificar las estructuras del cliente github de, por ejemplo, &lt;code&gt;github.PullRequest&lt;/code&gt; a &lt;code&gt;scm.PullRequest&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;La mayoría de las estructuras de github mapean 1-1 con los equivalentes &lt;a href=&#34;https://github.com/jenkins-x/go-scm&#34;&gt;jenkins-x/go-scm&lt;/a&gt; (por ejemplo, Issue, Commit, PullRequest) aunque la API go-scm tiende a devolver segmentos a los recursos de forma predeterminada. Sin embargo, hay algunas diferencias de nombres en diferentes partes de la API.&lt;/p&gt;
&lt;p&gt;p.ej. compare la API de &lt;code&gt;githubClient&lt;/code&gt; para &lt;a href=&#34;https://github.com/kubernetes/test-infra/blob/344024d30165cda6f4691cc178f25b16f1a1f5af/prow/plugins/lgtm/lgtm.go#L134-L150&#34;&gt;prow lgtm&lt;/a&gt; versus &lt;a href=&#34;https://github.com/jenkins-x/lighthouse/blob/master/pkg/prow/plugins/lgtm/lgtm.go#L135-L150&#34;&gt;lighthouse lgtm&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Todo el código relacionado con el plugin Prow vive en el árbol de paquetes &lt;a href=&#34;https://github.com/jenkins-x/lighthouse/tree/master/pkg/prow&#34;&gt;pkg/prow&lt;/a&gt;. En general, todo lo que hemos hecho es cambiar a &lt;a href=&#34;https://github.com/jenkins-x/go-scm&#34;&gt;jenkins-x/go-scm&lt;/a&gt; y cambiar los agentes de Prow actuales y, en su lugar, usar un solo agente Tekton usando &lt;a href=&#34;https://github.com/jenkins-x/lighthouse/blob/master/pkg/plumber/interface.go#L3-L6&#34;&gt;PlumberClient&lt;/a&gt; para activar los pipelines.&lt;/p&gt;
&lt;h2 id=&#34;variables-de-entornos&#34;&gt;Variables de entornos&lt;/h2&gt;
&lt;p&gt;Las siguientes variables de entornos son utilizadas:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Nombre&lt;/th&gt;
&lt;th&gt;Descripción&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;GIT_KIND&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;el tipo de servidor git: &lt;code&gt;github, bitbucket, gitea, stash&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;GIT_SERVER&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;la URL del servidor si no usa los proveedores públicos alojados de Git: &lt;a href=&#34;https://github.com&#34;&gt;https://github.com&lt;/a&gt; or &lt;a href=&#34;https://bitbucket.org&#34;&gt;https://bitbucket.org&lt;/a&gt; &lt;a href=&#34;https://gitlab.com&#34;&gt;https://gitlab.com&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;GIT_USER&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;el usuario git (bot name) a utilizar en las operacionse de Git&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;GIT_TOKEN&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;el token de git para realizar las operaciones en el repositorio (agregar comentarios, etiquetas, etc)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;HMAC_TOKEN&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;el token enviado desde el proveedor Git en los webhooks&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;JX_SERVICE_ACCOUNT&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;la cuenta de servicio que se usará para los pipelines generados&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Servidores de Jenkins Personalizados</title>
      <link>https://jenkins-x.io/es/docs/reference/components/custom-jenkins/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jenkins-x.io/es/docs/reference/components/custom-jenkins/</guid>
      <description>
        
        
        &lt;p&gt;Jenkins X proporciona CI/CD automatizado para las bibliotecas y microservicios que desee implementar en Kubernetes, pero ¿qué pasa con esas otros pipelines basadas en &lt;code&gt;Jenkinsfile&lt;/code&gt; que ya ha creado en un servidor Jenkins personalizado?&lt;/p&gt;
&lt;p&gt;Jenkins X ahora tiene una &lt;a href=&#34;https://github.com/jenkins-x-apps/jx-app-jenkins&#34;&gt;aplicación Jenkins&lt;/a&gt; que facilita agregar uno o más servidores Jenkins personalizados a su equipo y utilizar el servidor Jenkins personalizado para implementar cualquier pipeline personalizado que haya desarrollado.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NOTA&lt;/strong&gt; la aplicación Jenkins está diseñada solo para ejecutar pipelines personalizadas de &lt;code&gt;Jenkinsfile&lt;/code&gt; que haya desarrollado a mano; no es un motor de ejecución para los pipelines automatizadas de CI/CD en Jenkins X para cargas de trabajo de Kubernetes; para eso realmente recomendamos los &lt;a href=&#34;https://jenkins-x.io/es/about/concepts/jenkins-x-pipelines/&#34;&gt;pipelines de Jenkins X sin servidor&lt;/a&gt;, pero también puede usar un servidor Jenkins estático incorporado.&lt;/p&gt;
&lt;h2 id=&#34;por-qué-jenkins-personalizado&#34;&gt;¿Por qué Jenkins personalizado?&lt;/h2&gt;
&lt;p&gt;Esta aplicación le permite mantener su inversión en sus pipelines de Jenkins existentes, invocándolas en un Servidor Jenkins personalizado de su propia elección y configuración mientras comienza a usar más CI/CD automatizado en Jenkins X para nuevas bibliotecas y microservicios utilizando &lt;a href=&#34;https://jenkins-x.io/about/concepts/jenkins-x-pipelines/&#34;&gt;Pipelines de Jenkins sin servidor X&lt;/a&gt; o el servidor estático incorporado de Jenkins en Jenkins X.&lt;/p&gt;
&lt;p&gt;Luego puede mezclar y combinar entre el CI/CD automatizado en Jenkins X y sus pipelines personalizadas de Jenkins, ¡todo bien organizado junto con Jenkins X!&lt;/p&gt;
&lt;h2 id=&#34;instalar-un-jenkins-personalizado&#34;&gt;Instalar un Jenkins personalizado&lt;/h2&gt;
&lt;p&gt;Para instalar el servidor de Jenkins personalizado debe ejecutar el siguiente comando:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;jx add app jenkins
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Esto instalará un nuevo servidor Jenkins en su equipo actual. Entonces debería aparecer a través de &amp;hellip;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;jx open
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Esto también creará un token API automáticamente para que la CLI &lt;code&gt;jx&lt;/code&gt; pueda consultar o iniciar pipelines en el servidor Jenkins personalizado. Puede tomar un minuto más o menos para completar el trabajo de configuración.&lt;/p&gt;
&lt;h2 id=&#34;obtener-el-nombre-de-usuariocontraseña&#34;&gt;Obtener el nombre de usuario/contraseña&lt;/h2&gt;
&lt;p&gt;Desafortunadamente, hay una limitación en la aplicación Jenkins actual de que no le solicita la contraseña cuando agrega la aplicación Jenkins.&lt;/p&gt;
&lt;p&gt;Entonces, para encontrar la contraseña, tendrá que encontrarla a mano, me temo.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;descargar &lt;a href=&#34;https://github.com/mfuentesg/ksd&#34;&gt;ksd&lt;/a&gt; y adicionarlo a su $PATH&lt;/li&gt;
&lt;li&gt;escriba lo siguiente (debe necesitar cambiar el nombre del &lt;code&gt;Secret&lt;/code&gt; si utiliza un alias diferente en su servidor Jenkins):&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kubectl get secret jx-jx-app-jenkins -o yaml | ksd
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Luego podrá ver su usuario/contraseña en la pantalla si lo desea para para registrase en la interfaz de Jenkins a través del comando &lt;a href=&#34;https://jenkins-x.io/commands/deprecation/&#34;&gt;jx console&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;usando-el-jenkins-personalizado&#34;&gt;Usando el Jenkins personalizado&lt;/h2&gt;
&lt;p&gt;El comando &lt;code&gt;jx&lt;/code&gt; que funciona con servidores Jenkins puede funcionar directamente con su nuevo servidor Jenkins personalizado; aunque debe especificar que desea interactuar con un servidor Jenkins personalizado en lugar del motor de ejecución incorporado en Jenkins X (p.ej, &lt;a href=&#34;https://jenkins-x.io/about/concepts/jenkins-x-pipelines/&#34;&gt;Pipelines de Jenkins X sin servidor&lt;/a&gt; o el servidor Jenkins incorporado dentro de Jenkins X)&lt;/p&gt;
&lt;p&gt;Si solo tiene una aplicación Jenkins personalizada en su equipo, puede usar &lt;code&gt;-m&lt;/code&gt; para especificar que desea trabajar con un servidor Jenkins personalizado. De lo contrario, puede especificar &lt;code&gt;-n myjenkinsname&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# view the pipelines&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;jx get pipeline -m
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# view the log of a pipeline&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;jx get build log -m
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# view the Jenkins console&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;jx console -m
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# lets start a pipeline in the custom jenkins&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;jx start pipeline -m
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;administrar-servidores-jenkins-personalizados-a-través-de-gitops&#34;&gt;Administrar servidores Jenkins personalizados a través de GitOps&lt;/h2&gt;
&lt;p&gt;Hemos diseñado la aplicación Jenkins para Jenkins X utilizando el &lt;a href=&#34;https://jenkins-x.io/docs/contributing/addons/&#34;&gt;framework de extensión de la aplicación&lt;/a&gt;, lo que significa que puede administrar sus servidores Jenkins personalizados a través de &lt;a href=&#34;https://jenkins-x.io/docs/resources/guides/managing-jx/common-tasks/manage-via-gitops/&#34;&gt;GitOps&lt;/a&gt;, manteniendo todas las aplicaciones, su versión y configuración en git y utilizando las herramientas Jenkins X para agregar/actualizar/configurar/eliminar sus aplicaciones.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Registro Docker</title>
      <link>https://jenkins-x.io/es/docs/reference/components/docker-registry/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jenkins-x.io/es/docs/reference/components/docker-registry/</guid>
      <description>
        
        
        &lt;p&gt;Para poder crear y publicar imágenes de Docker necesitamos usar un Registro de Docker.&lt;/p&gt;
&lt;p&gt;De forma predeterminada, Jenkins X se entrega con un Registro Docker que se incluye en el namespace del sistema para Jenkins X junto con Jenkins y Nexus. Dado que este registro de Docker se ejecuta dentro de su clúster de Kubernetes y se usa internamente dentro de su clúster, es difícil exponerlo a través de HTTPS con certificados autofirmados, por lo que de manera predeterminada usamos registros de Docker inseguros para el rango de IP de IP de servicio en su clúster de Kubernetes.&lt;/p&gt;
&lt;h2 id=&#34;utilizando-un-registro-de-docker-diferente&#34;&gt;Utilizando un registro de Docker diferente&lt;/h2&gt;
&lt;p&gt;Si está utilizando la nube pública, puede aprovechar el registro de docker de sus proveedores de nube; o reutilice su propio registro de docker existente.&lt;/p&gt;
&lt;h3 id=&#34;si-está-utilizando-un-master-de-jenkins-estático&#34;&gt;Si está utilizando un Master de Jenkins Estático&lt;/h3&gt;
&lt;p&gt;Para especificar el host/puerto Docker Registry, puede usar la consola Jenkins:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ jx console
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Luego navegue a &lt;code&gt;Manage Jenkins -&amp;gt; Configure System&lt;/code&gt; y cambie la variable de entorno &lt;code&gt;DOCKER_REGISTRY&lt;/code&gt; para apuntar a su registro de docker de elección.&lt;/p&gt;
&lt;p&gt;Otro enfoque es agregar lo siguiente a su archivo &lt;code&gt;values.yaml&lt;/code&gt; para la personalización de los charts de Helm en la plataforma Jenkins X:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;jenkins&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;Servers&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;Global&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;EnvVars&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;DOCKER_REGISTRY&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;gcr.io&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;actualice-el-secreto-en-configjson&#34;&gt;Actualice el secreto en config.json&lt;/h2&gt;
&lt;p&gt;Va a necesitar actualizar el valor del secreto de docker almacenado en &lt;code&gt;config.json&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Puede logarlo a través del comando &lt;a href=&#34;https://jenkins-x.io/commands/jx_create_docker/&#34;&gt;jx create docker auth&lt;/a&gt;:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ jx create docker auth --host &amp;#34;foo.private.docker.registry&amp;#34; --user &amp;#34;foo&amp;#34; --secret &amp;#34;FooDockerHubToken&amp;#34; --email &amp;#34;fakeemail@gmail.com&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Si crea un fichero &lt;code&gt;config.json&lt;/code&gt; para su proveedor de registro de docker, p.ej para GCR en Google Cloud, seguramente necesitará algo como esto:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;credHelpers&amp;#34;&lt;/span&gt;: {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;gcr.io&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;gcloud&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;us.gcr.io&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;gcloud&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;eu.gcr.io&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;gcloud&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;asia.gcr.io&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;gcloud&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;staging-k8s.gcr.io&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;gcloud&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Para AWS es como esto:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;credsStore&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ecr-login&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Para actualizar el secreto &lt;code&gt;jenkins-docker-cfg&lt;/code&gt; puede hacerlo de la siguiente forma:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ kubectl delete secret jenkins-docker-cfg
$ kubectl create secret generic jenkins-docker-cfg --from-file=./config.json
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;NOTA&lt;/strong&gt; el archivo debe llamarse &lt;code&gt;config.json&lt;/code&gt; ya que el nombre del archivo se usa en la clave del &lt;code&gt;secret&lt;/code&gt; subyacente en kubernetes&lt;/p&gt;
&lt;h2 id=&#34;utilizando-docker-hub&#34;&gt;Utilizando Docker Hub&lt;/h2&gt;
&lt;p&gt;Si desea almacenar las imágenes en DockerHub, entonces debe modificar su fichero &lt;code&gt;config.json&lt;/code&gt; como se describe a continuación:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;auths&amp;#34;&lt;/span&gt;: {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;https://index.docker.io/v1/&amp;#34;&lt;/span&gt;: {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;auth&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;MyDockerHubToken&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;email&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;myemail@acme.com&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;utilizando-jfrog-bintray-artifactory&#34;&gt;Utilizando jFrog BinTray (Artifactory)&lt;/h2&gt;
&lt;p&gt;Utilizar JFrog BinTray como registro privado para docker es posible. Esto ha sido probado solamente durante la creación del clúster y pasando el parámetro &lt;code&gt;--docker-registry=private-reg.bintray.io&lt;/code&gt;. Luego, después de creado el clúster, va a necesitar lo siguiente:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Borre el &lt;code&gt;Secret&lt;/code&gt; existente con el nombre &lt;code&gt;jenkins-docker-cfg&lt;/code&gt; ejecutando:&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ kubectl delete secret jenkins-docker-cfg
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;
&lt;li&gt;Cree un fichero local con el nombre &lt;code&gt;config.json&lt;/code&gt; y su valor debe estar en el siguiente formato (actualice los valores basados en su registro de usuario y FQDN):&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;auths&amp;#34;&lt;/span&gt;: {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;https://private-reg.bintray.io&amp;#34;&lt;/span&gt;: {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;auth&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;username:password (base64 encoded)&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;email&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;myemail@acme.com&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;
&lt;li&gt;Cree el nuevo recurso &lt;code&gt;Secret&lt;/code&gt; con nombre &lt;code&gt;jenkins-docker-cfg&lt;/code&gt; con el contenido del fichero &lt;code&gt;config.json&lt;/code&gt; como lo siguiente:&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ kubectl create secret generic jenkins-docker-cfg --from-file&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;./config.json
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Con esto debe ser sufiente, ahora debe poder ejecutar los pipelines y almacenar las imágenes en registro jFrog BinTray.&lt;/p&gt;
&lt;h3 id=&#34;montar-el-secreto-para-su-registro&#34;&gt;Montar el Secreto para su registro&lt;/h3&gt;
&lt;p&gt;Su registro docker va a necesitar un Secreto que necesita ser montado en la &lt;a href=&#34;https://jenkins-x.io/docs/resources/guides/managing-jx/common-tasks/pod-templates/&#34;&gt;Plantilla Pod&lt;/a&gt;.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Servidores Git</title>
      <link>https://jenkins-x.io/es/docs/reference/components/git/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jenkins-x.io/es/docs/reference/components/git/</guid>
      <description>
        
        
        &lt;p&gt;Jenkins X usa de manera predeterminada &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt;, la solución gratuita de alojamiento público de Git para proyectos de código abierto.&lt;/p&gt;
&lt;p&gt;Sin embargo, al trabajar en la empresa, es posible que desee utilizar diferentes servidores git.&lt;/p&gt;
&lt;h2 id=&#34;configurar-servidores-git-a-través-de-boot&#34;&gt;Configurar servidores Git a través de boot&lt;/h2&gt;
&lt;p&gt;Recomendamos encarecidamente que use &lt;a href=&#34;https://jenkins-x.io/docs/getting-started/setup/boot/&#34;&gt;boot&lt;/a&gt; para instalar y configurar Jenkins X.&lt;/p&gt;
&lt;p&gt;Si está utilizando boot, utilice &lt;a href=&#34;https://jenkins-x.io/es/docs/getting-started/setup/boot/#git&#34;&gt;estas instrucciones para configurar Git&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;listar-servidores-git&#34;&gt;Listar servidores Git&lt;/h2&gt;
&lt;p&gt;Puede listar los servidores Git configurados a través del comando &lt;a href=&#34;https://jenkins-x.io/commands/jx_get_git/&#34;&gt;jx get git&lt;/a&gt;:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;jx get git
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;alert alert-primary&#34; role=&#34;alert&#34;&gt;


    &lt;p&gt;&lt;strong&gt;NOTA:&lt;/strong&gt; Todos los proveedores de Git mencionados aquí son compatibles si está utilizando Jenkins Static Masters. Sin embargo, si está utilizando &lt;strong&gt;Jenkins X Serverless con Tekton&lt;/strong&gt;, solo se admite GitHub. Esto significa que todos los demás proveedores de Git, incluido GitHub Enterprise, no son compatibles actualmente debido a cómo Prow se comunica con las API.&lt;/p&gt;
&lt;p&gt;Sin embargo, estamos integrando &lt;a href=&#34;https://github.com/jenkins-x/lighthouse&#34;&gt;Lighthouse&lt;/a&gt; para garantizar el soporte para los proveedores de Git listados en esta página en un entorno Jenkins X Serverless muy pronto.&lt;/p&gt;


&lt;/div&gt;

&lt;h2 id=&#34;utilizar-diferentes-proveedores-git-por-entornos&#34;&gt;Utilizar diferentes proveedores Git por entornos&lt;/h2&gt;
&lt;p&gt;Cuando instales Jenkins X, creará repositorios de Git para &lt;code&gt;Staging&lt;/code&gt; y &lt;code&gt;Production&lt;/code&gt; usando GitHub.&lt;/p&gt;
&lt;p&gt;Si desea utilizar un proveedor de Git diferente para sus entornos, cuando instale Jenkins X agregue el parámetro &lt;code&gt;--no-default-environments&lt;/code&gt; en el comando &lt;a href=&#34;https://jenkins-x.io/commands/jx_create_cluster/&#34;&gt;jx create cluster&lt;/a&gt; o &lt;a href=&#34;https://jenkins-x.io/commands/deprecation/&#34;&gt;jx install&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;p.ej. para &lt;a href=&#34;https://jenkins-x.io/es/docs/getting-started/setup/create-cluster/&#34;&gt;crear un nuevo clúster&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ jx create cluster gke --no-default-environments
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;o &lt;a href=&#34;https://jenkins-x.io/docs/resources/guides/managing-jx/common-tasks/install-on-cluster/&#34;&gt;instalarlo en un clúster existente&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ jx install --no-default-environments
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Luego, una vez que Jenkins X esté instalado, puede &lt;a href=&#34;#agregar-un-nuevo-proveedor-git&#34;&gt;agregar un nuevo proveedor git&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Luego, cuando el proveedor git está configurado, puede verificar que esté disponible y que tenga el &lt;code&gt;gitKind&lt;/code&gt; correcto a través de:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ jx get git server
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Ahora cree los entornos &lt;code&gt;Staging&lt;/code&gt; y &lt;code&gt;Production&lt;/code&gt; utilizando el proveedor de git que desee a través de:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ jx create env staging --git-provider-url&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;https://gitproviderhostname.com
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ jx create env production --git-provider-url&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;https://gitproviderhostname.com
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;agregar-un-nuevo-proveedor-git&#34;&gt;Agregar un nuevo proveedor git&lt;/h2&gt;
&lt;p&gt;Si ya tiene un servidor git en algún lugar, puede agregarlo a Jenkins X a través de &lt;a href=&#34;https://jenkins-x.io/commands/jx_create_git_server/&#34;&gt;jx create git server&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;jx create git server gitKind someURL
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Donde &lt;code&gt;gitKind&lt;/code&gt; es uno de los tipos de proveedores de git compatibles como &lt;code&gt;github, gitea, gitlab, bitbucketcloud, bitbucketserver&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Puede verificar qué URL del servidor y los valores &lt;code&gt;gitKind&lt;/code&gt; se configuran a través de:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;jx get git server
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;NOTA:&lt;/strong&gt; asegúrese de establecer el &lt;code&gt;gitKind&lt;/code&gt; correcto para su proveedor de git; de lo contrario, se invocará el proveedor de API REST subyacente incorrecto.&lt;/p&gt;
&lt;h2 id=&#34;github-enterprise&#34;&gt;GitHub Enterprise&lt;/h2&gt;
&lt;p&gt;Para adicionar al servidor GitHub Enterprise intente:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;jx create git server github https://github.foo.com -n GHE
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;jx create git token -n GHE myusername
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Donde &lt;code&gt;-n&lt;/code&gt; es el nombre del servicio git.&lt;/p&gt;
&lt;h2 id=&#34;bitbucket-cloud&#34;&gt;BitBucket Cloud&lt;/h2&gt;
&lt;p&gt;Para adicionar BitBucket Cloud intente:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;jx create git server bitbucketcloud -n BitBucket https://bitbucket.org
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;jx create git token -n BitBucket myusername
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Por favor, asegúrece que &lt;code&gt;gitKind&lt;/code&gt; está correctamente escrito como &lt;code&gt;bitbucketcloud&lt;/code&gt; a través del comando:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;jx get git server
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;y que aparece en la columna &lt;code&gt;Kind&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;bitbucket-server&#34;&gt;BitBucket Server&lt;/h2&gt;
&lt;p&gt;Para adicionar BitBucket Standalone Server intente:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;jx create git server bitbucketserver -n BitBucket https://your_server_address
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;jx create git token -n BitBucket myusername
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;gitlab&#34;&gt;Gitlab&lt;/h2&gt;
&lt;p&gt;Para adicionar el servidor Gitlab y el token intente:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;jx create git server gitlab https://gitlab.com/ -n gitlab
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;jx create git token -n gitlab myusername
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;adicionar-tokens-de-usuarios&#34;&gt;Adicionar tokens de usuarios&lt;/h3&gt;
&lt;p&gt;Para utilizar este servidor git necesitarás adicionar el nombre de usuario y el token del API a través de &lt;a href=&#34;https://jenkins-x.io/commands/jx_create_git_token/&#34;&gt;jx create git token&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;jx create git token -n myProviderName myUserName
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Se le preguntará el token del API.&lt;/p&gt;
&lt;h3 id=&#34;proveedores-git-hospedado-en-kubernetes&#34;&gt;Proveedores Git hospedado en Kubernetes&lt;/h3&gt;
&lt;p&gt;Puede instalar proveedores git dentro del clúster de kubernetes que ejecuta Jenkins X.&lt;/p&gt;
&lt;p&gt;p.ej. hay un complemento para &lt;a href=&#34;https://gitea.io/en-us/&#34;&gt;gitea&lt;/a&gt; que le permite instalar &lt;code&gt;gitea&lt;/code&gt; como parte de su instalación de Jenkins X.&lt;/p&gt;
&lt;p&gt;Para usar &lt;a href=&#34;https://gitea.io/en-us/&#34;&gt;gitea&lt;/a&gt; con Jenkins X, debe habilitar el complemento &lt;code&gt;gitea&lt;/code&gt; antes de instalar Jenkins X:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;jx edit addon gitea -e true
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Puede ver los complementos habilitados a través de &lt;a href=&#34;https://jenkins-x.io/commands/jx_get_addons/&#34;&gt;jx get addons&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;jx get addons
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Ahora, cuando &lt;a href=&#34;https://jenkins-x.io/docs/getting-started/&#34;&gt;instales Jenkins X&lt;/a&gt; también instalará el componente &lt;code&gt;gitea&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Luego, cada vez que Jenkins X necesite crear un repositorio git para un entorno o para un nuevo proyecto, el servidor gitea aparecerá en la lista de selección.&lt;/p&gt;
&lt;h4 id=&#34;limitaciones-conocidas-de-gitea&#34;&gt;Limitaciones conocidas de gitea&lt;/h4&gt;
&lt;p&gt;Al momento de escribir, &lt;a href=&#34;https://issues.jenkins-ci.org/browse/JENKINS-50459&#34;&gt;el plugin de gitea para Jenkins&lt;/a&gt; no actualiza correctamente el PR y los estados de construcción de git commit que rompen los canales de promoción de GitOps. La promoción puede funcionar a través de la aprobación manual, pero el pipeline informa un fallo.&lt;/p&gt;
&lt;p&gt;Otro problema es que los nuevos proyectos creados por &lt;code&gt;jx&lt;/code&gt; dentro de &lt;code&gt;gitea&lt;/code&gt; no habilitan los &lt;a href=&#34;https://github.com/go-gitea/go-sdk/issues/100&#34;&gt;botones de combinación en los PR&lt;/a&gt;. La solución es que después de crear un proyecto en github, vaya a la página de &lt;code&gt;Settings&lt;/code&gt; para el repositorio dentro de la consola web de &lt;code&gt;gitea&lt;/code&gt; y active los botones de mezcla allí.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Helm 3</title>
      <link>https://jenkins-x.io/es/docs/reference/components/helm3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jenkins-x.io/es/docs/reference/components/helm3/</guid>
      <description>
        
        
        &lt;p&gt;Jenkins X utiliza &lt;a href=&#34;https://www.helm.sh/&#34;&gt;Helm&lt;/a&gt; para instalar Jenkins X e instalar las aplicaciones que cree en cada uno de los &lt;a href=&#34;https://jenkins-x.io/about/concepts/features/#environments&#34;&gt;Entornos&lt;/a&gt; (como &lt;code&gt;Staging&lt;/code&gt; y &lt;code&gt;Production&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NOTA&lt;/strong&gt; hasta que Helm 3 sea GA recomendamos que las personas utilicen &lt;a href=&#34;https://jenkins-x.io/news/helm-without-tiller/&#34;&gt;Helm 2.x sin Tiller&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Actualmente se está desarrollando Helm 3 que tiene una serie de grandes mejoras:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;elimine el componente del lado del servidor, Tiller, para que la &lt;code&gt;instalación de Helm&lt;/code&gt; use el RBAC del usuario/ServiceAccount actual&lt;/li&gt;
&lt;li&gt;las versiones se vuelven conscientes de los namespaces evitando la necesidad de crear nombres de versiones únicos a nivel global&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;En el momento de escribir Helm 3 todavía está en su desarrollo, pero para mejorar los comentarios, hemos agregado soporte para Helm 2 y Helm 3 en Jenkins X.&lt;/p&gt;
&lt;p&gt;Puede usar Helm 2 o Helm 3 para hacer cualquiera de estas cosas:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;instalar Jenkins X&lt;/li&gt;
&lt;li&gt;instalar sus aplicaciones en los entornos &lt;code&gt;Staging&lt;/code&gt; y &lt;code&gt;Production&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;p.ej. puede utilizar Helm 2 para instalar Jenkins X, luego utilizar Helm 3 para sus entornos &lt;code&gt;Staging&lt;/code&gt; y &lt;code&gt;Production&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Vea cómo especificar cuál versión de Helm utilizar.&lt;/p&gt;
&lt;h2 id=&#34;utilizar-helm-3-para-instalar-jenkins-x&#34;&gt;Utilizar helm 3 para instalar Jenkins X&lt;/h2&gt;
&lt;p&gt;Cuando instale Jenkins X a través de &lt;code&gt;jx create cluster ...&lt;/code&gt; o &lt;code&gt;jx install&lt;/code&gt; puede especificar &lt;code&gt;--helm3&lt;/code&gt; para utilizar helm 3 en vez de helm 2.x.&lt;/p&gt;
&lt;p&gt;Si lo instala utilizando helm 2, entonces su equipo por defecto utilizará helm 2 para su liberaciones. Si lo instala utilizando helm 3, entonces su equipo utilizará por defecto la versión 3.&lt;/p&gt;
&lt;p&gt;Para cambiar la versión de helm utilizada por su equipo use el comando &lt;a href=&#34;https://jenkins-x.io/commands/jx_edit_helmbin/&#34;&gt;jx edit helmbin&lt;/a&gt;:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;jx edit helmbin helm3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;o para cambiar a helm 2:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;jx edit helmbin helm
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Puede ver la configuración actual para su equipo a través del comando &lt;a href=&#34;https://jenkins-x.io/commands/jx_get_helmbin/&#34;&gt;jx get helmbin&lt;/a&gt;:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;jx get helmbin
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Básicamente la &lt;a href=&#34;https://jenkins-x.io/docs/resources/guides/managing-jx/common-tasks/pod-templates/&#34;&gt;plantilla del pod&lt;/a&gt; contiene ambos binarios:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;helm&lt;/code&gt; which is a 2.x distro of helm&lt;/li&gt;
&lt;li&gt;&lt;code&gt;helm3&lt;/code&gt; which is a 3.x distro of helm&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Plantillas Pod</title>
      <link>https://jenkins-x.io/es/docs/reference/components/pod-templates/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jenkins-x.io/es/docs/reference/components/pod-templates/</guid>
      <description>
        
        
        &lt;p&gt;Implementamos pipelines CI/CD utilizando pipelines declarativos de Jenkins a través del fichero &lt;code&gt;Jenkinsfile&lt;/code&gt; en el código de cada aplicación o entorno de repositorio git.&lt;/p&gt;
&lt;p&gt;Utilizamos &lt;a href=&#34;https://github.com/jenkinsci/kubernetes-plugin&#34;&gt;plugins de Kubernetes&lt;/a&gt; para que Jenkins pueda activar nuevos pods en Kubernetes para cada construcción, lo que nos da un grupo elástico de agentes para ejecutar tuberías gracias a Kubernetes.&lt;/p&gt;
&lt;p&gt;El complemento Kubernetes utiliza plantillas (&lt;em&gt;pod templates&lt;/em&gt;) para definir el pod utilizado para ejecutar un pipeline de CI/CD que consiste en:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;uno o más contenedores de compilación para ejecutar comandos dentro (p.ej, sus herramientas de compilación como &lt;code&gt;mvn&lt;/code&gt; o &lt;code&gt;npm&lt;/code&gt; junto con las herramientas que utilizamos para otras partes del pipeline como &lt;code&gt;git, jx, helm, kubectl&lt;/code&gt;, etc.)&lt;/li&gt;
&lt;li&gt;volúmenes para persistencia&lt;/li&gt;
&lt;li&gt;Variables de entorno&lt;/li&gt;
&lt;li&gt;secretos para que el pipeline pueda escribir en repositorios git, registros de docker, repositorios maven/npm /helm, etc&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;refiriéndose-a-plantillas-de-pod&#34;&gt;Refiriéndose a Plantillas de Pod&lt;/h2&gt;
&lt;p&gt;Jenkins X viene con un conjunto predeterminado de plantillas de pod para los lenguajes y tiempos de ejecución admitidos en nuestros paquetes de compilación y se denominan algo así como: &lt;code&gt;jenkins-$PACKNAME&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Por ejemplo, el &lt;a href=&#34;https://github.com/jenkins-x-buildpacks/jenkins-x-kubernetes/blob/master/packs/maven/&#34;&gt;paquete de compilación de Maven&lt;/a&gt; utiliza la plantilla de pod &lt;code&gt;jenkins-maven&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Luego podemos referirnos al nombre de la &lt;a href=&#34;https://github.com/jenkins-x-buildpacks/jenkins-x-kubernetes/blob/master/packs/maven/Jenkinsfile#L1-L4&#34;&gt;plantilla de pod en el fichero Jenkinsfile&lt;/a&gt; usando la sintaxis del agente &lt;code&gt;agent { label &amp;quot;jenkins-$PACKNAME&amp;quot; }&lt;/code&gt; en el pipeline declarativo. p.ej.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-groovy&#34; data-lang=&#34;groovy&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// my declarative Jenkinsfile
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;pipeline &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    agent &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      label &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;jenkins-maven&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    environment &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    stages &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      stage&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;CI Build and push snapshot&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        steps &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          container&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;maven&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            sh &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;mvn deploy&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;enviar-nuevas-plantillas-de-pod&#34;&gt;Enviar nuevas Plantillas de Pod&lt;/h2&gt;
&lt;p&gt;Si está trabajando en un nuevo &lt;a href=&#34;https://jenkins-x.io/architecture/build-packs/&#34;&gt;paquete de compilación&lt;/a&gt;, nos encantaría que &lt;a href=&#34;https://jenkins-x.io/docs/contributing/&#34;&gt;envíe&lt;/a&gt; una nueva plantilla de pod y podemos incluirla en la distribución Jenkins X!&lt;/p&gt;
&lt;p&gt;Ahora sigue las instrucciones sobre cómo hacer esto. Por favor, si algo no está claro, ven &lt;a href=&#34;https://jenkins-x.io/community/&#34;&gt;únete a la comunidad y pregunta&lt;/a&gt; ¡estaremos encantados de ayudarte!&lt;/p&gt;
&lt;p&gt;Para enviar un nuevo paquete de compilación:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bifurcar el repositorio &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-platform/&#34;&gt;jenkins-x-platform&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;agregue su paquete de compilación al &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-platform/blob/master/jenkins-x-platform/values.yaml&#34;&gt;archivo values.yaml en el repositorio jenkins-x-platform&lt;/a&gt; en la sección &lt;code&gt;jenkins.Agent.PodTemplates&lt;/code&gt; de YAML&lt;/li&gt;
&lt;li&gt;es posible que desee comenzar copiando/pegando la plantilla de pod existente más similar (por ejemplo, copie &lt;code&gt;Maven&lt;/code&gt; si está trabajando en un pod de compilación basado en Java) y simplemente configure el nombre, la etiqueta y la imagen, etc.&lt;/li&gt;
&lt;li&gt;ahora envíe una solicitud de extracción en el repositorio &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-platform/&#34;&gt;jenkins-x-platform&lt;/a&gt; para su plantilla de pod&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;construir-contenedores&#34;&gt;Construir contenedores&lt;/h3&gt;
&lt;p&gt;Al usar plantillas de pod y pipeliens de Jenkins, puede usar muchos contenedores diferentes para cada herramienta. p.ej. un contenedor para &lt;code&gt;maven&lt;/code&gt; y otro para &lt;code&gt;git&lt;/code&gt;, etc.&lt;/p&gt;
&lt;p&gt;Hemos encontrado que es mucho más simple tener un solo contenedor de constructor con todas las herramientas comunes en su interior. Esto también significa que puede usar &lt;code&gt;kubectl exec&lt;/code&gt; o (/commands/jx_rsh) para abrir un shell dentro del pod de compilación y tener todas las herramientas que necesita disponibles para depurar/diagnosticar pipelines con problemas.&lt;/p&gt;
&lt;p&gt;Por lo tanto, tenemos una imagen de docker base (&lt;a href=&#34;https://github.com/jenkins-x/builder-base&#34;&gt;builder-base&lt;/a&gt;) en el generador que contiene &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-builders-base/blob/master/Dockerfile.common#L4-L15&#34;&gt;todas las diferentes herramientas&lt;/a&gt; que tendemos a utilizar en los pipelines de CI/CD como &lt;code&gt;jx, skaffold, helm, git, updatebot&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Si desea usar una sola imagen de generador para su nueva plantilla de pod, puede usar la base de generador y luego agregar sus herramientas personalizadas en la parte superior.&lt;/p&gt;
&lt;p&gt;p.ej. &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-builders/tree/master/builder-maven&#34;&gt;builder-maven&lt;/a&gt; utiliza un &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-builders/blob/master/builder-maven/Dockerfile#L1&#34;&gt;Dockerfile&lt;/a&gt; para hacer referencia al constructor base.&lt;/p&gt;
&lt;p&gt;Entonces, lo más simple podría ser copiar un constructor similar, como &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-builders/tree/master/builder-maven&#34;&gt;builder-maven&lt;/a&gt; y luego editar el &lt;code&gt;Dockerfile&lt;/code&gt; para agregar las herramientas de compilación que necesite.&lt;/p&gt;
&lt;p&gt;Nos encantan las solicitudes de extracción y las &lt;a href=&#34;https://jenkins-x.io/docs/contributing/&#34;&gt;contribuciones&lt;/a&gt;, así que envíe solicitudes de extracción para nuevos contenedores de compilación y plantillas de pods, ¡y estamos más que felices de &lt;a href=&#34;https://jenkins-x.io/docs/contributing/&#34;&gt;ayudar&lt;/a&gt;!&lt;/p&gt;
&lt;h2 id=&#34;agregar-sus-propias-plantillas-de-pod&#34;&gt;Agregar sus propias Plantillas de Pod&lt;/h2&gt;
&lt;p&gt;Para mantener las cosas Limpias y simples, tendemos a definir plantillas de pod en la configuración de Jenkins y luego nos referimos al nombre en el &lt;code&gt;Jenkinsfile&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Hay intentos de facilitar la inserción de definiciones de plantillas de pod dentro de su &lt;code&gt;Jenkinsfile&lt;/code&gt; si lo necesita; aunque una plantilla de pod tiende a tener muchas cosas específicas del entorno de desarrollador dentro, como secretos, por lo que preferiríamos mantener la mayoría de las plantillas de pod dentro del código fuente de su entorno de desarrollo en lugar de copiarlas/pegarlas en cada aplicación.&lt;/p&gt;
&lt;p&gt;Hoy, la forma más fácil de agregar nuevas plantillas de pod es a través de la consola Jenkins. p.ej.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ jx console
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Eso abrirá la consola de Jenkins. Luego navegue a &lt;code&gt;Manage Jenkins&lt;/code&gt; (en el menú de la izquierda) y luego a &lt;code&gt;Configure System&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Ahora se enfrentará a una gran página de opciones de configuración ;) Las plantillas de pod generalmente están en la parte inferior; debería ver todas las plantillas de pod actuales para cosas como maven, NodeJS, etc.&lt;/p&gt;
&lt;p&gt;Puede editar/agregar/eliminar plantillas de pod en esa página y presionar Guardar.&lt;/p&gt;
&lt;p&gt;Sin embargo, tenga en cuenta que a largo plazo esperamos &lt;a href=&#34;https://github.com/jenkins-x/jx/issues/604&#34;&gt;mantener su entorno de desarrollo a través de GitOps, como lo hacemos para Staging y Production&lt;/a&gt;, lo que significa que los cambios realizados a través de la interfaz de usuario de Jenkins se perderán al &lt;a href=&#34;https://jenkins-x.io/commands/deprecation/&#34;&gt;actualizar su entorno de desarrollo&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A largo plazo, esperamos agregar las plantillas de pod en su archivo &lt;code&gt;values.yaml&lt;/code&gt; en el repositorio git de su entorno de desarrollador como lo hacemos para el &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-platform/blob/master/values.yaml#L194-L431&#34;&gt;chart jenkins-x-platform&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Si está creando plantillas de pod utilizando herramientas de compilación de código abierto, puede ser más sencillo &lt;a href=&#34;#enviar-nuevas-plantillas-de-pod&#34;&gt;enviar su plantilla de pod en una solicitud de extracción&lt;/a&gt; y podemos agregar esa plantilla de pod en futuras versiones de Jenkins X.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Vault</title>
      <link>https://jenkins-x.io/es/docs/reference/components/vault/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jenkins-x.io/es/docs/reference/components/vault/</guid>
      <description>
        
        
        

&lt;div class=&#34;pageinfo pageinfo-primary&#34;&gt;
Tenga en cuenta que actualmente Vault solo funciona en Google Cloud Platform (GCP) con Google Kubernetes Engine (GKE). Estamos trabajando para ampliar el soporte a otros proveedores de la nube.
&lt;/div&gt;

&lt;h1 id=&#34;qué-es-vault&#34;&gt;¿Qué es Vault?&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.vaultproject.io&#34;&gt;Vault&lt;/a&gt; es un proyecto de código abierto para administrar secretos de forma segura y es nuestra forma preferida de administrar secretos en sus entornos en Jenkins X.&lt;/p&gt;
&lt;p&gt;En las infraestructuras informáticas tradicionales, todos los recursos y componentes (hardware, redes, disponibilidad, seguridad e implementación) así como los costos laborales asociados se gestionan localmente. Terceros entornos informáticos como proveedores de servicios en la nube y de Git ofrecen soluciones descentralizadas con distintas ventajas en el servicio de fiabilidad y costos sobre las soluciones tradicionales.&lt;/p&gt;
&lt;p&gt;Sin embargo, un problema con el uso de servicios en la nube, almacenamiento distribuido y repositorios remotos es la falta de redes confiables, hardware examinado, y otras medidas de seguridad observadas de cerca practicadas en entornos locales de
infraestructura. Por conveniencia, los usuarios a menudo almacenan información como credenciales de autenticación en repositorios públicos y abiertos, expuestos a posibles actividades maliciosas.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.vaultproject.io/&#34;&gt;Hashicorp &lt;em&gt;Vault&lt;/em&gt;&lt;/a&gt; es una herramienta que centraliza la gestión de secretos: recursos que proporcionan autenticación a su entorno informático, como tokens, claves, contraseñas y certificados.&lt;/p&gt;
&lt;p&gt;Jenkins X maneja los recursos de seguridad y autenticación a través de la integración de Vault. Los usuarios pueden implementar Vault para almacenar y administrar de forma segura todos los aspectos de su plataforma de desarrollo.&lt;/p&gt;
&lt;p&gt;Jenkins X instala y configura Vault para su clúster de manera predeterminada a través del proceso de creación del clúster.&lt;/p&gt;
&lt;h2 id=&#34;características-de-vault&#34;&gt;Características de Vault&lt;/h2&gt;
&lt;p&gt;Vault es una herramienta para acceder y almacenar secretos de usuario. Gestiona el Complejidad del acceso seguro a los recursos:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Almacenamiento de secretos: Vault coloca los secretos en un formato cifrado en un depósito (bucket) de almacenamiento remoto.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Creación y eliminación de secretos - Vault crea secretos para un acceso dinámicos a depósitos de almacenamiento, acceso efímero que son
creados/destruidos según sea necesario para el acceso temporal a datos, y genera claves para la autenticación de la base de datos.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Cifrado de datos: Vault almacena los secretos en un depósito de almacenamiento remoto en directorios seguros con cifrado seguro.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Jenkins X interactúa con Vault a través del programa de línea de comando &lt;code&gt;jx&lt;/code&gt;. Hay comandos para crear, eliminar y gestionar secretos y bóvedas.&lt;/p&gt;
&lt;p&gt;Jenkins X usa Vault para almacenar todos los secretos de Jenkins X, como el token de acceso personal de GitHub generado para el pipeline del bot (sistema) cuando &lt;a href=&#34;https://jenkins-x.io/docs/getting-started/setup/boot/&#34;&gt;crea un clúster de Jenkins X cluster&lt;/a&gt;. También almacena cualquier secreto de GitOps, como contraseñas para los depósitos de almacenamiento y claves para acceso seguro al servidor.&lt;/p&gt;
&lt;p&gt;Los secretos pueden ser recuperados por el pipeline o por la línea de comando si está registrado en la cuenta asociada con el servicio Kubernetes, así como en cualquier secreto almacenado en el espacio de nombres &lt;code&gt;jx&lt;/code&gt; para el pipeline.&lt;/p&gt;
&lt;p&gt;Las bóvedas se aprovisionan en Kubernetes usando &lt;code&gt;vault-operator&lt;/code&gt;, un Controlador Kubernetes de código abierto instalado cuando Vault está siendo  configurado durante la creación del clúster y la instalación de Jenkins X.&lt;/p&gt;
&lt;h1 id=&#34;utilizando-vault-en-el-cli&#34;&gt;Utilizando Vault en el CLI&lt;/h1&gt;
&lt;p&gt;Primero necesita descargar e instalar el CLI &lt;a href=&#34;https://github.com/starkandwayne/safe&#34;&gt;safe&lt;/a&gt; para Vault.&lt;/p&gt;
&lt;p&gt;Una vez instalado &lt;a href=&#34;https://github.com/starkandwayne/safe&#34;&gt;safe&lt;/a&gt; puede ejecutar el siguiente comando:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;eval `jx get vault-config`
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ahora debe poder utilizar &lt;a href=&#34;https://github.com/starkandwayne/safe&#34;&gt;safe&lt;/a&gt; CLI para acceder a Vault.&lt;/p&gt;
&lt;p&gt;Puede entonces obtener un secreto a través de:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;safe get /secret/my-cluster-name/creds/my-secret
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;o puede actualizar un secreto a través de:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;safe set /secret/my-cluster-name/creds/my-secret username=myname password=mytoken
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Si tiene un blob de JSON para codificar como secreto, como una clave de cuenta de servicio, convierta el archivo a base64 primero y luego configúrelo &amp;hellip;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cat my-service-account.json | base64 &amp;gt; myfile.txt
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;safe set /secret/my-cluster-name/creds/my-secret json&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;@myfile.txt
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;configurar-dns-y-tls-para-vault&#34;&gt;Configurar DNS y TLS para Vault&lt;/h1&gt;
&lt;p&gt;Para una instalación segura de Jenkins X, debe habilite TLS cuando interactúe con el servicio de almacenamiento. Para configurar TLS, primero debe configurar los ajustes de DNS de Zona en Google Cloud Platform, y luego configure los ajustes de DNS externos para el &lt;code&gt;Ingress&lt;/code&gt; y TLS en el
fichero de configuración ``jx-requirements.yml`.&lt;/p&gt;
&lt;h2 id=&#34;configurar-google-cloud-dns&#34;&gt;Configurar Google Cloud DNS&lt;/h2&gt;
&lt;p&gt;Para configurar el acceso DNS y TLS de Vault correctamente, debe configurar Google Cloud DNS de forma adecuada.&lt;/p&gt;
&lt;p&gt;Debe tener un nombre de dominio registrado, por ejemplo &lt;code&gt;www.acmecorp.example&lt;/code&gt; antes de configurar el DNS en la Zona de Configuraciones de Google. Para obtener más información, consulte la guía de &lt;a href=&#34;https://cloud.google.com/dns/docs/quickstart#create_a_managed_public_zone&#34;&gt;Creación de una Zona Administrada Pública&lt;/a&gt;.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Navegue hasta la página de &lt;a href=&#34;https://console.cloud.google.com/projectselector2/home/dashboard&#34;&gt;Selección de Proyecto&lt;/a&gt; y elija su proyecto de Google Cloud Platform.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://console.cloud.google.com/networking/dns/zones/~new&#34;&gt;Cree un DNS de Zona&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Elija como su &lt;em&gt;Tipo de zona&lt;/em&gt; Public.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Escriba un &lt;em&gt;Nombre de zona&lt;/em&gt; para su zona.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Adicione un sufijo al DNS in &lt;em&gt;DNS name&lt;/em&gt;, p.ej &lt;code&gt;acmecorp.example&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Seleccione su &lt;em&gt;DNSSEC&lt;/em&gt; o el estado de Seguridad DNS, que debe se configurado como &lt;code&gt;Off&lt;/code&gt; para este ejemplo.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;(Opcional) Ingrese una &lt;em&gt;Descripción&lt;/em&gt; para su zona DNS.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Clic en &lt;code&gt;Create&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Una vez creada, se carga la página &lt;em&gt;Zone Details&lt;/em&gt;. &lt;em&gt;NS&lt;/em&gt; (servidor de nombres) y los registros &lt;em&gt;SOA&lt;/em&gt; (Inicio de autoridad) se crean automáticamente para su dominio (por ejemplo, &lt;code&gt;acmecorp.example&lt;/code&gt;)&lt;/p&gt;
&lt;h2 id=&#34;configurar-dns-externo-en-jenkins-x&#34;&gt;Configurar DNS Externo en Jenkins X&lt;/h2&gt;
&lt;p&gt;Una vez que haya configurado Google Cloud DNS, puede usar la página de &lt;a href=&#34;https://console.cloud.google.com/net-services/dns/zones&#34;&gt;Zonas&lt;/a&gt; en su proyecto de Google Cloud Platform para configurar su dominio externo.&lt;/p&gt;


&lt;div class=&#34;alert alert-primary&#34; role=&#34;alert&#34;&gt;


    NOTA: El DNS externo actualizará automáticamente los registros DNS si reutiliza el nombre de dominio, por lo que si elimina un clúster antiguo y crea uno nuevo, conservará la misma configuración de dominio para el nuevo clúster.

&lt;/div&gt;

&lt;p&gt;Para configurar DNS Externo:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Elija un nombre DNS único; puede usar dominios anidados (por ejemplo, cluster1.acmecorp.example). Ingrese el nombre en el campo Nombre DNS&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ejecute el comando &lt;code&gt;jx create domain&lt;/code&gt; contra su nombre de dominio, por ejemplo:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ jx create domain gke --domain cluster1.acmecorp.example
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;Se le preguntará la información que se necesite para la configuración:

1. Seleccione su proyecto Google Cloud Platform del listado disponible.

2. Actualice sus servidores administrados existentes para usar la lista que se muestra de los servidores de nombres DNS en la nube. Copie la lista para usar en los próximos pasos.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;El siguiente paso es configurar GCP:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Desde la página &lt;a href=&#34;https://console.cloud.google.com/net-services/dns/zones&#34;&gt;Zonas&lt;/a&gt; de Google Cloud Platform, cambie el &lt;em&gt;Resource Record Type&lt;/em&gt; a &lt;code&gt;NS&lt;/code&gt;) y use los valores predeterminados para su dominio para &lt;em&gt;TTL&lt;/em&gt; (&lt;code&gt;5&lt;/code&gt;) y &lt;em&gt;TTL Unit&lt;/em&gt; (&lt;code&gt;minutos&lt;/code&gt;).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Agregue el primer servidor de nombres al campo &lt;em&gt;Servidor de nombres&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Clic en &lt;code&gt;Add item&lt;/code&gt; y adicione cualquier servidor de nombre.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Clic en &lt;code&gt;Create&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Finalmente, configure Jenkins X para los nuevos nombres de dominio:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Edite el fichero &lt;code&gt;jx-requirements.yml&lt;/code&gt; y actualice el campo &lt;code&gt;dominio&lt;/code&gt; (en &lt;code&gt;Ingress&lt;/code&gt;) a su nombre de dominio, por ejemplo &lt;code&gt;cluster1.acmecorp.example&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;En la configuración &lt;em&gt;tls&lt;/em&gt;, habilite TLS con &lt;code&gt;enabled: true&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;El fichero &lt;code&gt;jx-requirements.yml&lt;/code&gt; quedaría de la siguiente forma si utilizamos las configuraciones mencionadas:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;gitops&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;ingress&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;domain&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;cluster1.acmecorp.example&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;externalDNS&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;namespaceSubDomain&lt;/span&gt;: -&lt;span style=&#34;color:#ae81ff&#34;&gt;jx.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;tls&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;email&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;certifiable@acmecorp.example&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;enabled&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;production&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;secretStorage&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;vault&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&#34;alert alert-primary&#34; role=&#34;alert&#34;&gt;


    Recuerde ejecutar el comando &lt;code&gt;jx boot&lt;/code&gt; para que los cambios tengan efecto en su entorno.

&lt;/div&gt;

&lt;h1 id=&#34;crear-un-vault&#34;&gt;Crear un Vault&lt;/h1&gt;
&lt;p&gt;De forma predeterminada, se crea un servicio Vault utilizando &lt;a href=&#34;https://jenkins-x.io/getting-started/boot/&#34;&gt;jx boot&lt;/a&gt; para crear su clúster, a menos que haya especificado durante la configuración del clúster no cree Vault. En este caso, puede crear una instalación posterior con la interfaz de línea de comandos &lt;code&gt;jx create&lt;/code&gt;:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ jx create vault
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;El programa le preguntará el nombre para su Vault (p.ej &lt;code&gt;acmevault&lt;/code&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;El programa le pedirá su Google Cloud Zone de elección. Consulte &lt;a href=&#34;https://cloud.google.com/compute/docs/regions-zones/&#34;&gt;Regiones y zonas&lt;/a&gt; en la documentación de Google Cloud para obtener más información. En este ejemplo, &lt;code&gt;us-east1-c&lt;/code&gt; se elige por su proximidad a la sede de Acme.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Si tiene una cuenta de depósito de almacenamiento configurada desde la creación de un clúster con &lt;code&gt;jx boot&lt;/code&gt;, entonces el comando &lt;code&gt;jx create vault&lt;/code&gt; analizará su instalación en busca de depósitos de almacenamiento relacionados con Vault y, si se encuentra, le pedirá que apruebe eliminar y volver a crear el Vault desde cero.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;El programa le preguntará por el &lt;em&gt;Expose type&lt;/em&gt; para el Vault para crear reglas y rutas para el balanceo de carga del clúster y otros servicios. El valor predeterminado es &lt;code&gt;Ingress&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;El programa solicitará un dominio de clúster. El valor predeterminado es el creado en &lt;a href=&#34;https://jenkins-x.io/docs/getting-started/setup/boot/&#34;&gt;el proceso de creación de Cluster&lt;/a&gt;, como 192.168.1.100.nip.io.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;El programa le pedirá una &lt;code&gt;URLTemplate&lt;/code&gt;. Presione &lt;code&gt;Enter&lt;/code&gt; para usar el valor predeterminado.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;El programa verificará sus respuestas a las preguntas anteriores en resumen y le pedirá que apruebe la creación de Vault (el valor predeterminado es &lt;code&gt;Yes&lt;/code&gt;).&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Código Fuente</title>
      <link>https://jenkins-x.io/es/docs/reference/components/source/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jenkins-x.io/es/docs/reference/components/source/</guid>
      <description>
        
        
        &lt;p&gt;Jenkins X está construido sobre los hombros de gigantes y también tiene muchos repositorios de diferentes orígenes para hacer lograr varios objetivos, desde herramientas CLI, imágenes de docker, helm charts y &lt;a href=&#34;https://jenkins-x.io/docs/contributing/addons/&#34;&gt;aplicaciones como complementos&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Esta página enumera las principales organizaciones y repositorios.&lt;/p&gt;
&lt;h2 id=&#34;organizaciones&#34;&gt;Organizaciones&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/jenkins-x&#34;&gt;jenkins-x&lt;/a&gt; la organización principal para el código fuente&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/jenkins-x-apps&#34;&gt;jenkins-x-apps&lt;/a&gt; contiene el estándar de &lt;a href=&#34;https://jenkins-x.io/docs/contributing/addons/&#34;&gt;aplicaciones de componentes&lt;/a&gt; para Jenkins X&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/jenkins-x-buildpacks&#34;&gt;jenkins-x-buildpacks&lt;/a&gt; contiene los paquetes de &lt;a href=&#34;https://jenkins-x.io/docs/resources/guides/managing-jx/common-tasks/build-packs/&#34;&gt;compilación disponibles&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/jenkins-x-charts&#34;&gt;jenkins-x-charts&lt;/a&gt; los principales helm charts que distribuimos&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/jenkins-x-images&#34;&gt;jenkins-x-images&lt;/a&gt; contiene algunas compilaciones de imágenes de docker personalizadas&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/jenkins-x-quickstarts&#34;&gt;jenkins-x-quickstarts&lt;/a&gt; los proyectos de inicio rápido utilizados por &lt;a href=&#34;https://jenkins-x.io/docs/getting-started/first-project/create-quickstart/&#34;&gt;create quickstart&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/jenkins-x-test-projects&#34;&gt;jenkins-x-test-projects&lt;/a&gt; proyectos de prueba que usamos en casos de prueba&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;repositorios&#34;&gt;Repositorios&lt;/h2&gt;
&lt;p&gt;Aquí mencionaremos a algunos de los principales repositorios en las organizaciones anteriores:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/jenkins-x/jx&#34;&gt;jenkins-x/jx&lt;/a&gt; el repositorio principal que crea la CLI &lt;code&gt;jx&lt;/code&gt; y los pasos de pipelines reutilizables&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/jenkins-x/jx-docs&#34;&gt;jenkins-x/jx-docs&lt;/a&gt; la documentación basada en Hugo que genera este sitio web&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/jenkins-x/bdd-jx&#34;&gt;jenkins-x/bdd-jx&lt;/a&gt; las pruebas BDD que utilizamos para verificar los cambios de plataforma y verificar los PR en &lt;a href=&#34;https://github.com/jenkins-x/jx&#34;&gt;jenkins-x/jx&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-platform&#34;&gt;jenkins-x/jenkins-x-platform&lt;/a&gt; el principal helm chart compuesto para la plataforma Jenkins X&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-versions&#34;&gt;jenkins-x/jenkins-x-versions&lt;/a&gt; contiene el &lt;a href=&#34;https://jenkins-x.io/es/about/concepts/version-stream/&#34;&gt;flujo de versiones&lt;/a&gt;: las versiones estables de todos los &lt;em&gt;charts&lt;/em&gt; y &lt;em&gt;paquetes&lt;/em&gt; de CLI&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/jenkins-x/cloud-environments&#34;&gt;jenkins-x/cloud-environments&lt;/a&gt; las configuraciones helm para diferentes proveedores de la nube&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;construir-pods-e-imágenes&#34;&gt;Construir pods e imágenes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-builders&#34;&gt;jenkins-x/jenkins-x-builders&lt;/a&gt; genera las imágenes estáticas de docker de los pod de compilación del servidor jenkins&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-image&#34;&gt;jenkins-x/jenkins-x-image&lt;/a&gt; genera la imagen docker para el servidor jenkins estático que usamos por defecto&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-serverless&#34;&gt;jenkins-x/jenkins-x-serverless&lt;/a&gt; genera las imágenes de docker para &lt;a href=&#34;https://jenkins-x.io/news/serverless-jenkins/&#34;&gt;jenkins sin servidor&lt;/a&gt; cuando se utiliza &lt;a href=&#34;https://jenkins-x.io/architecture/prow/&#34;&gt;Prow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;herramientas&#34;&gt;Herramientas&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/jenkins-x/lighthouse&#34;&gt;jenkins-x/lighthouse&lt;/a&gt; la solución estratégica para webhooks y ChatOps para múltiples proveedores de git&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/jenkins-x/exposecontroller&#34;&gt;jenkins-x/exposecontroller&lt;/a&gt; una &lt;code&gt;Deployment&lt;/code&gt; o &lt;code&gt;Job&lt;/code&gt; que se puede usar para generar/actualizar recursos de &lt;code&gt;Ingress&lt;/code&gt; (o &lt;code&gt;Route&lt;/code&gt; en OpenShift) si cambia su dominio DNS o habilita TLS; también puede inyectar URL externas en su aplicación a través de la inyección del &lt;code&gt;ConfigMap&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
  </channel>
</rss>
